<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>The Essential GNSS Project: cmatrix.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>cmatrix.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
'c' functions for vector and matrix operations. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Glenn D. MacGougan (GDM) </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2007-03-19 </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>1.04</dd></dl>
<b>LICENSE</b> <b>INFORMATION</b> <br>
 Copyright (c) 2007, Glenn D. MacGougan, Zenautics Technologies Inc. <br>
<p>
Redistribution pertains only to the following files and their contents. <br>
<ul>
<li><a class="el" href="_matrix_8h.html" title="The matrix class.">Matrix.h</a><br>
</li><li><a class="el" href="_matrix_8cpp.html" title="The matrix class.">Matrix.cpp</a><br>
</li><li><a class="el" href="cmatrix_8h.html" title="&#39;c&#39; functions for vector and matrix operations.">cmatrix.h</a><br>
</li><li>cmatrix_basic.lib (for windows), cmatrix_basic_lib.a (for linux)<br>
</li></ul>
<p>
Redistribution and use in source and binary forms, with or without modification, of the specified files is permitted provided the following conditions are met: <br>
<p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <br>
</li><li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <br>
</li><li>The name(s) of the contributor(s) may not be used to endorse or promote products derived from this software without specific prior written permission. <br>
</li></ul>
<p>
THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<p>
<b>NOTES:</b> <br>
 This code was developed using rigourous unit testing for every function and operation. Despite any rigorous development process, bugs are inevitable. Please report bugs and suggested fixes to glenn_at_zenautics.com.<br>
 
<p>Definition in file <a class="el" href="cmatrix_8h-source.html">cmatrix.h</a>.</p>

<p>

<p>
<a href="cmatrix_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst_complex.html">stComplex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A complex data struct.  <a href="structst_complex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_t_x.html">MTX</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The deep level matrix struct. The matrix is either real or complex.  <a href="struct_m_t_x.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#3f0b76d92b803447ebd36d906759173e">MTX_Initialize_MTXEngine</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function must be called first by users of cmatrix!  <a href="#3f0b76d92b803447ebd36d906759173e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#fc11a41223a37a68397e1ee5ba70a902">MTX_Enable1x1MatricesForTreatmentAsScalars</a> (BOOL enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to set if matrices that are single elements (1x1) are treated as scalars for math operations or whether the regular matrix rules apply. THIS IS ENABLED BY DEFAULT.  <a href="#fc11a41223a37a68397e1ee5ba70a902"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#0cffba9663e4c7bf7929dcd5e9467b6b">MTX_isNull</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a null matrix?  <a href="#0cffba9663e4c7bf7929dcd5e9467b6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ac8e75465c8906f510f817e8da24fd37">MTX_isConformalForMultiplication</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are matrices A &amp; B conformal for multiplication, real * real.  <a href="#ac8e75465c8906f510f817e8da24fd37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#001dd2617c6417965e483d22b118f3f1">MTX_isConformalForAddition</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are matrices A &amp; B conformat for addition/subtraction, real + real.  <a href="#001dd2617c6417965e483d22b118f3f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#b5731da64e9d26d27c279552e02d21f4">MTX_isSquare</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a square matrix?  <a href="#b5731da64e9d26d27c279552e02d21f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9455faec647442c0c3b4259cf9c57325">MTX_isSameSize</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">are A and B the same size?  <a href="#9455faec647442c0c3b4259cf9c57325"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#3857f486478bd797e93902df492ecf7f">MTX_Init</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> matrix struct to appropriate zero values. This must always be called for proper operation!  <a href="#3857f486478bd797e93902df492ecf7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8e2cffbbe72f6b8048cebc8a197ac76f">MTX_SetComment</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the matrix comment string.  <a href="#8e2cffbbe72f6b8048cebc8a197ac76f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#c2a6efafec90bc1ddc1c99185a18585a">MTX_Free</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the matrix data from memory if dynamically allocated. Zero the struct members.  <a href="#c2a6efafec90bc1ddc1c99185a18585a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8c0e28fe06fa9cd39ef04753053b3dc5">MTX_Calloc</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned nrows, const unsigned ncols, const BOOL isReal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate matrix data (set to zero).  <a href="#8c0e28fe06fa9cd39ef04753053b3dc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#285ed3f66b2a522a6c5f0de4b6c421cb">MTX_Malloc</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned nrows, const unsigned ncols, const BOOL isReal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate matrix data (not set to zero).  <a href="#285ed3f66b2a522a6c5f0de4b6c421cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8b0f9acaf54cf4979cd5eeeeded96a7d">MTX_SetValue</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, const unsigned col, const double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a scalar value in the matrix.  <a href="#8b0f9acaf54cf4979cd5eeeeded96a7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#e8b1520cf96455a72ba1f4d95215bb02">MTX_SetComplexValue</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, const unsigned col, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a complex value in the matrix.  <a href="#e8b1520cf96455a72ba1f4d95215bb02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#5d420707d92079f563175d8a1fdd975e">MTX_Complex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const <a class="el" href="struct_m_t_x.html">MTX</a> *Re, const <a class="el" href="struct_m_t_x.html">MTX</a> *Im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix M = Re + Im*i, where Re and Im are real matrices.  <a href="#5d420707d92079f563175d8a1fdd975e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ff98269455216bc2fd7fb540f1d70ab9">MTX_SetComplexColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, const <a class="el" href="struct_m_t_x.html">MTX</a> *Re, const <a class="el" href="struct_m_t_x.html">MTX</a> *Im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the specified column in Matrix M to Re + Im*i, where Re and Im are real matrices. The dimensions of M must already be valid.  <a href="#ff98269455216bc2fd7fb540f1d70ab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6671de01f24b261f2ef32ba3b89af252">MTX_ConvertRealToComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a real matrix to a complex matrix.  <a href="#6671de01f24b261f2ef32ba3b89af252"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#d4a7af3c61343b4072798229ec8ce082">MTX_ConvertComplexToReal</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a complex marix to a real matrix using only the imaginary component A = real(B).  <a href="#d4a7af3c61343b4072798229ec8ce082"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#b3eaeffebef0b08a25abae680ab5e194">MTX_ConvertComplexToImag</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a complex marix to a real matrix using only the imaginary component A = imag(B).  <a href="#b3eaeffebef0b08a25abae680ab5e194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#b833a251fc8357281d00bf53bdb4fe1f">MTX_Real</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *Re)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the real component of matrix M.  <a href="#b833a251fc8357281d00bf53bdb4fe1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#79c5d6c0a69860807652c170718c90c7">MTX_RealColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, <a class="el" href="struct_m_t_x.html">MTX</a> *Re)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the real component of column col of matrix M.  <a href="#79c5d6c0a69860807652c170718c90c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#929a03f6126966d62bc89c20dee39bc6">MTX_Imag</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *Im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the imaginary component of matrix M.  <a href="#929a03f6126966d62bc89c20dee39bc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#1fc9244847b0e502c0b6613e168ca9f8">MTX_ImagColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, <a class="el" href="struct_m_t_x.html">MTX</a> *Im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the imaginary component of column col of matrix M.  <a href="#1fc9244847b0e502c0b6613e168ca9f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#519d759c2913aefffa7d3c7c138dd30f">MTX_Magnitude</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *Magnitude)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If M is a real matrix, Magnitude is a copy. If M is a complex matrix, Magnitude is a real matrix = sqrt( re*re + im*im ).  <a href="#519d759c2913aefffa7d3c7c138dd30f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#93db857a6b2a3ca31ba0a3ab2533cf31">MTX_Phase</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *Phase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If M is a real matrix, Phase is a zero matrix. If M is a complex matrix, Phase is a real matrix = atan2(im,re).  <a href="#93db857a6b2a3ca31ba0a3ab2533cf31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#db90a9ab8687d787963acca2afda47c9">MTX_Conjugate</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If M is a real matrix, nothing is done. If M is a complex matrix, the conjugate is set.  <a href="#db90a9ab8687d787963acca2afda47c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a5c1a441658ba66ebcace32cd1a13ced">MTX_RemoveColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a single column from the matrix.  <a href="#a5c1a441658ba66ebcace32cd1a13ced"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#aaf7d19d52936661dc01b7a234e2f194">MTX_RemoveColumnsAfterIndex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">remove all the columns 'after' the column index given.  <a href="#aaf7d19d52936661dc01b7a234e2f194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7e08bfd45679efbd7450137f38f8a423">MTX_InsertColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned dst_col, const unsigned src_col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">insert a column into another matrix.  <a href="#7e08bfd45679efbd7450137f38f8a423"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#05df54c4d4e3df1b518dc63046bdfe6d">MTX_AddColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned src_col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a column to the Matrix.  <a href="#05df54c4d4e3df1b518dc63046bdfe6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a5bc010ce942348b8724a33693e11fe4">MTX_Concatonate</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const <a class="el" href="struct_m_t_x.html">MTX</a> *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two matrices with the same nrows, A becomes A|B,.  <a href="#a5bc010ce942348b8724a33693e11fe4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#c9238b3c6825a054ce85788eb5d24963">MTX_Redim</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned nrows, const unsigned ncols)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Redimension the matrix, original data is saved in place, new data is set to zero.  <a href="#c9238b3c6825a054ce85788eb5d24963"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#01277701346e92df67a9b163396b4e42">MTX_Resize</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned nrows, const unsigned ncols, const BOOL isReal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the matrix, original data is lost, new data is set to zero, must specify if the matrix is real or complex.  <a href="#01277701346e92df67a9b163396b4e42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#61b2bf40f73795dc24cf8c1f3166388e">MTX_Copy</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the src data to dst matrix, resize dst if possible &amp; necessary.  <a href="#61b2bf40f73795dc24cf8c1f3166388e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a98c4dbe64c54fc019fd44d3da3b56f0">MTX_CopyIntoColumnWiseVector</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the src matrix data [m cols x n rows] to dst vector [1 col x m*n rows], resize dst if possible &amp; necessary.  <a href="#a98c4dbe64c54fc019fd44d3da3b56f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9b840d63b0107b08d82ba52af45a6b37">MTX_SetFromStaticMatrix</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const double mat[], const unsigned nrows, const unsigned ncols)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the dst matrix from the static 'c' style matrix indexed by mat[i*ncols + j].  <a href="#9b840d63b0107b08d82ba52af45a6b37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#0d72dffd498413e73a6e97a9013582ce">MTX_CopyColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned col, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the src data in column col to dst matrix, resize dst if possible &amp; necessary.  <a href="#0d72dffd498413e73a6e97a9013582ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8a5ffda4a5c28279215a30590dff8272">MTX_CopyRow</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned row, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the src data in row, row, to dst matrix, resize dst if possible &amp; necessary.  <a href="#8a5ffda4a5c28279215a30590dff8272"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#1b1cfeecc8d8168cbbb7ab6a136fb359">MTX_CopyRowIntoAColumnMatrix</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned row, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the src data in row 'row' (1xn) to dst matrix (nx1), resize dst if possible &amp; necessary. dst becomes (nx1).  <a href="#1b1cfeecc8d8168cbbb7ab6a136fb359"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#d51694bc9da56402208eae8cfecce739">MTX_InsertSubMatrix</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned dst_row, const unsigned dst_col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a submatrix (src) into dst, starting at indices dst(row,col).  <a href="#d51694bc9da56402208eae8cfecce739"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#da1e1411e7bfb1f5354ecf4f2babbae2">MTX_Zero</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zero the entire matrix.  <a href="#da1e1411e7bfb1f5354ecf4f2babbae2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#fac186d0b357219446e15f815131d5ce">MTX_ZeroColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zero all elements in a specified column.  <a href="#fac186d0b357219446e15f815131d5ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#5a737cd1fb0f036f4206e0a3d8a01149">MTX_ZeroRow</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zero all elements in a specified row.  <a href="#5a737cd1fb0f036f4206e0a3d8a01149"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#e89a25fe578ca59bdd1ee8bdce5c2064">MTX_Fill</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the matrix with the given value.  <a href="#e89a25fe578ca59bdd1ee8bdce5c2064"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#d7b002d28b6c5264ae50b46deb705a1c">MTX_FillComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the matrix with the given complex value.  <a href="#d7b002d28b6c5264ae50b46deb705a1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#0958fc561a0d20e38c5cfad41d7b6202">MTX_FillColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned col, const double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the matrix column with the given value.  <a href="#0958fc561a0d20e38c5cfad41d7b6202"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#e6ef5cfa30ab3cb1ef1d0edbb7e398e8">MTX_FillColumnComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned col, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the matrix column with the given complex value.  <a href="#e6ef5cfa30ab3cb1ef1d0edbb7e398e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#223916347f0c27d111450a6808665be8">MTX_FillRow</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned row, const double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the matrix row with the given value.  <a href="#223916347f0c27d111450a6808665be8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#936ddf8f308096b5d98bef51f61ed15e">MTX_FillRowComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const unsigned row, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the matrix row with the given complex value.  <a href="#936ddf8f308096b5d98bef51f61ed15e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8a32ad969b50d147306766da1d9f2880">MTX_FlipColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse the order of elements of a column.  <a href="#8a32ad969b50d147306766da1d9f2880"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#043cd7939ae2a0145d29e21ed9ee5ccd">MTX_FlipRow</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse the order of elements of a row.  <a href="#043cd7939ae2a0145d29e21ed9ee5ccd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#0a872a42ca5383a6dcf243335c4feaae">MTX_Identity</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the matrix to an identity.  <a href="#0a872a42ca5383a6dcf243335c4feaae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#d9cc1c9cc68a104f678e0403e72272dd">MTX_Transpose</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose the matrix src into the matris dst.  <a href="#d9cc1c9cc68a104f678e0403e72272dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#285c3a16c10ca260a59425dbfb951026">MTX_TransposeInplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose the matrix as an inplace operation.  <a href="#285c3a16c10ca260a59425dbfb951026"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#cb94314d49118919c8893008ddabd84e">MTX_Round</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned precision)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the matrix elements to the specified precision.<br>
 e.g. precision = 0 1.8 -&gt; 2<br>
 e.g. precision = 1, 1.45 -&gt; 1.5<br>
 e.g. precision = 2 1.456 -&gt; 1.46<br>
 e.g. precision = 3, 1.4566 -&gt; 1.457<br>
.  <a href="#cb94314d49118919c8893008ddabd84e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#698185a8c08797a8ed89d573a017a3bf">MTX_Floor</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the matrix elements to the nearest integers towards minus infinity.  <a href="#698185a8c08797a8ed89d573a017a3bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#78d4e20464c3c74dbff4d1697073ba95">MTX_Ceil</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the matrix elements to the nearest integers towards infinity.  <a href="#78d4e20464c3c74dbff4d1697073ba95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#15ddcb38e352700703ac7eb327f57cf5">MTX_Fix</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the matrix elements of X to the nearest integers towards zero.  <a href="#15ddcb38e352700703ac7eb327f57cf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#805f6a81b4d2f675294c3b1dea2b8749">MTX_DetermineFileDelimiter</a> (const char *path, char *delimiter, BOOL *hasComment, char **comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the matrix file delimiter and if a comment line is available.  <a href="#805f6a81b4d2f675294c3b1dea2b8749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#69adb99d106c54790270a25559edd576">MTX_DetermineFileSize</a> (const char *path, unsigned *size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the size of a file.  <a href="#69adb99d106c54790270a25559edd576"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6db369ba46d7dbf1d962ad6bb3692e26">MTX_DetermineNumberOfColumnsInDataString</a> (const char *datastr, unsigned *ncols)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of columns in the data string provided.  <a href="#6db369ba46d7dbf1d962ad6bb3692e26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#57ee434463838d4f4d2f27d6103b311c">MTX_DetermineNumberOfColumnsInDataStringCplx</a> (const char *datastr, const char delimiter, unsigned *ncols)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of columns in the complex data string provided. The delimiter is needed, 'w' indicates whitespace.  <a href="#57ee434463838d4f4d2f27d6103b311c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#534aeb533410b9bdecb38d938df28da0">MTX_ReadFromFileRealOnly</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a real-only matrix from a file (ASCII formatted, any common delimiters). This function will also read in <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> BINARY formatted files.  <a href="#534aeb533410b9bdecb38d938df28da0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a7ea41b13f45934ed3ee4a6410856880">MTX_ReadFromFile</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read either a real or complex matrix from a file (ASCII formatted, any common delimiters). This function will also read in <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> BINARY formatted files.  <a href="#a7ea41b13f45934ed3ee4a6410856880"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#5edba86cc03ecfcd32e49d3ef48280bc">MTX_SetFromMatrixString</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *strMatrix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the matrix from a matrix string.  <a href="#5edba86cc03ecfcd32e49d3ef48280bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#77b7656a696dd32633bb32cc8a607c20">MTX_ValueToString</a> (const double value, const unsigned width, const unsigned precision, const BOOL isReal, const BOOL alignLeft, char *ValueBuffer, const unsigned ValueBufferSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a value to a string with the specified width and precision. analogous to sprintf( ValueBuffer, "%'blank''-'width.precision'g'", value );.  <a href="#77b7656a696dd32633bb32cc8a607c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7f2c4e8f49c1f7bf7165638284c195a6">MTX_Print</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path, const unsigned width, const unsigned precision, const BOOL append)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to a file with specifed width and precision. MTX_PrintAutoWidth is recommended over this function, "%'blank''-'width.precision'g'".  <a href="#7f2c4e8f49c1f7bf7165638284c195a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#007814c53f6007fa7318293532d3ab90">MTX_Print_ToBuffer</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, char *buffer, const unsigned maxlength, const unsigned width, const unsigned precision)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to a buffer of maxlength with specifed width and precision. MTX_PrintAutoWidth is recommended over this function, "%'blank''-'width.precision'g'".  <a href="#007814c53f6007fa7318293532d3ab90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#00e65dc76850178b7dd0bc8ebb8dcc52">MTX_PrintAutoWidth</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path, const unsigned precision, const BOOL append)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to a file with automatically determined column width. and the specified precision, uses "%'blank''-'autowidth.precision'g'".  <a href="#00e65dc76850178b7dd0bc8ebb8dcc52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ac9c6054cce8871bdcf9c77091d240b8">MTX_PrintStdoutAutoWidth</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned precision)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to stdout with automatically determined column width. and the specified precision, uses "%'blank''-'autowidth.precision'g'".  <a href="#ac9c6054cce8871bdcf9c77091d240b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#cd7a6829c5fde0020dc231a82e2ee33b">MTX_PrintAutoWidth_ToBuffer</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, char *buffer, const unsigned maxlength, const unsigned precision)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to a buffer of maxlenth with automatically determined column width. and the specified precision, uses "%'blank''-'autowidth.precision'g'".  <a href="#cd7a6829c5fde0020dc231a82e2ee33b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#954215ef6e13791b8eeaa3688876c23a">MTX_PrintDelimited</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path, const unsigned precision, const char delimiter, const BOOL append)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to a file with specifed precision and delimiter. Use MTX_PrintAutoWidth if print using whitespace as a delimiter is required, uses "%.precision'g'".  <a href="#954215ef6e13791b8eeaa3688876c23a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4914542f51f70387aa15f8d3edb22c58">MTX_PrintDelimited_ToBuffer</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, char *buffer, const unsigned maxlength, const unsigned precision, const char delimiter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the matrix to a file with specifed precision and delimiter. Use MTX_PrintAutoWidth if print using whitespace as a delimiter is required, uses "%.precision'g'".  <a href="#4914542f51f70387aa15f8d3edb22c58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8ac92ccc98baa6280f29e4a19456dc7a">MTX_PrintRowToString</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, char *buffer, const unsigned maxlength, const int width, const int precision)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a row to a string buffer.  <a href="#8ac92ccc98baa6280f29e4a19456dc7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ca0fc95165b254b69e3a13838093597e">MTX_Add_Scalar</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a scalar double to matrix M, ie: M += 5.  <a href="#ca0fc95165b254b69e3a13838093597e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#fd1ee574d085999cc0a6629d78444637">MTX_Add_ScalarComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a scalar complex to matrix M, ie: M += (5 + 3i).  <a href="#fd1ee574d085999cc0a6629d78444637"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9b600cfcf5c18b3eaa24b99b4717604c">MTX_Subtract_Scalar</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts a scalar double from matrix M, ie: M -= 5.  <a href="#9b600cfcf5c18b3eaa24b99b4717604c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#abb93dab812a9ec96ebb0985644c9a21">MTX_Subtract_ScalarComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts a scaler complex from matrix M, ie: M -= (5+3i).  <a href="#abb93dab812a9ec96ebb0985644c9a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4f7f7b6909be3ef37ccd0763933f4ca8">MTX_Multiply_Scalar</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply M with a double scalar inplace, ie: M *= 5.  <a href="#4f7f7b6909be3ef37ccd0763933f4ca8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#669d1d7991e566150b5b48cade33599f">MTX_Multiply_ScalarComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply M with a complex scalar inplace, ie: M *= (5+3i).  <a href="#669d1d7991e566150b5b48cade33599f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#e51575e19fda85dfca222202db480f97">MTX_Divide_Scalar</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide M by scaler double inplace, ie: M /= 5.  <a href="#e51575e19fda85dfca222202db480f97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4918909ff04abb78de083ef2fae7f8ea">MTX_Divide_ScalarComplex</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const double re, const double im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide M by scaler complex inplace, ie: M /= (5+3i).  <a href="#4918909ff04abb78de083ef2fae7f8ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ef9448a648cc5dc20ed86430e1f75fca">MTX_Abs</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute value of each element in the matrix.  <a href="#ef9448a648cc5dc20ed86430e1f75fca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8c0a73e5670cffc4b824b5abf249f273">MTX_Sqr</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the value^2 of each element in the matrix.  <a href="#8c0a73e5670cffc4b824b5abf249f273"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#df75a569a1edc476cc879e5531528678">MTX_Sqrt</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sqrt(value) of each element in the matrix. A real matrix is converted to complex if any elements are negative. e.g. sqrt(-1) = -i.  <a href="#df75a569a1edc476cc879e5531528678"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#2e3c2abe491dd922c5442482068d0ccf">MTX_Exp</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If real, computes the exp(value) of each element in the matrix. If complex, computes exp(M) = exp(real)*(cos(imag)+i*sin(imag)).  <a href="#2e3c2abe491dd922c5442482068d0ccf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a6c590e5318f16990164f4364f8248c2">MTX_Ln</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the natural logarithm, ln(value) of each element in the matrix.  <a href="#a6c590e5318f16990164f4364f8248c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#f6ea71b580baa3c667f979c7ed902d3f">MTX_Pow</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, <a class="el" href="struct_m_t_x.html">MTX</a> *dst, const double power_re, const double power_im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise all elements in src^(power_re + power_im*i) and store in dst. If power is just real, power_im = 0.0.  <a href="#f6ea71b580baa3c667f979c7ed902d3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9d281c72f9ad9b27683682e0ac37ff6b">MTX_PowInplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *src, const double power_re, const double power_im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise all elements in src^(power_re + power_im*i). If power is just real, power_im = 0.0.  <a href="#9d281c72f9ad9b27683682e0ac37ff6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#f3c372bf5b556f75d810f8e3f87ad5c3">MTX_Arctan</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the arctan, atan(value) of each element in the matrix.  <a href="#f3c372bf5b556f75d810f8e3f87ad5c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a4180894f10dd78b873194d82d1f32be">MTX_Increment</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add +1.0 to all elements, e.g. M++.  <a href="#a4180894f10dd78b873194d82d1f32be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#63911129bb62d4eed8fb3c4246f557a3">MTX_Decrement</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract 1.0 from all elements, e.g. M--.  <a href="#63911129bb62d4eed8fb3c4246f557a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8b0fa9eb0aa5519d1d9d448c2077d1d3">MTX_Add_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add A += B, inplace.  <a href="#8b0fa9eb0aa5519d1d9d448c2077d1d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#1a28dfd23986104c5e0a3f6401d29a72">MTX_Subtract_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract A -= B, inplace.  <a href="#1a28dfd23986104c5e0a3f6401d29a72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ea1ded94d6ec84f3f47c0cfbfbaa9248">MTX_PreMultiply_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply A = B*A, inplace.  <a href="#ea1ded94d6ec84f3f47c0cfbfbaa9248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#3bcaf5747f7364c95fb4169f7d186547">MTX_PostMultiply_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply A = A*B, inplace.  <a href="#3bcaf5747f7364c95fb4169f7d186547"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#47e8962f4f001db852fd9b8b7eef1c7c">MTX_DotMultiply_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dot multiply A .*= B, inplace (A.data[col][row] = A.data[col][row]*B.data[col][row]).  <a href="#47e8962f4f001db852fd9b8b7eef1c7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#78c213cc6635e7c588fe41df41049b6c">MTX_DotDivide_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dot divide A ./= B, inplace (A.data[col][row] = A.data[col][row]/B.data[col][row]).  <a href="#78c213cc6635e7c588fe41df41049b6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#efa26d0d4dbda6beca41e43be8f07f9e">MTX_Add</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B, const <a class="el" href="struct_m_t_x.html">MTX</a> *C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add A = B+C.  <a href="#efa26d0d4dbda6beca41e43be8f07f9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#5a1578331c3ac05b50c41a52623b5527">MTX_Subtract</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B, const <a class="el" href="struct_m_t_x.html">MTX</a> *C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract A = B-C.  <a href="#5a1578331c3ac05b50c41a52623b5527"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6908c105fbe0c79dd831abc3dfa52df2">MTX_Multiply</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B, const <a class="el" href="struct_m_t_x.html">MTX</a> *C)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply A = B*C.  <a href="#6908c105fbe0c79dd831abc3dfa52df2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9fce4613f0766843fcb7e31c6ab74e3f">MTX_IsEqual</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *A, const <a class="el" href="struct_m_t_x.html">MTX</a> *B, const double tolerance, BOOL *isEqual)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rest if A == B to within the specified tolerance.  <a href="#9fce4613f0766843fcb7e31c6ab74e3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#5848306f54988031751920501cdd855b">MTX_ColumnDiff</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *Diff, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Difference and approximte derivative for column col. The Diff is the column difference vector. diff = col[1:N-2] - col[0:N-1].  <a href="#5848306f54988031751920501cdd855b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7b12b53fd5c489acaae7f392eb81ed3f">MTX_Diff</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *Diff)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Difference and approximate derivative. The Diff matrix is composed of the column difference vectors. for(i=0:M-1){ diff_i = col_i[1:N-2] - col_i[0:N-1] }.  <a href="#7b12b53fd5c489acaae7f392eb81ed3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#14ac174801d052881666d4cb208f1f2c">MTX_MaxColIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im, unsigned *row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the maximum element in the specified column and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal maximum elements, the first index from the beginning is returned.  <a href="#14ac174801d052881666d4cb208f1f2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#00609631e59fb1d897c30c8459ec9c56">MTX_MaxRowIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the maximum element in the specified row and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal maximum elements, the first index from the beginning is returned.  <a href="#00609631e59fb1d897c30c8459ec9c56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#564e5943a56d59214dca1fb0a6562fbf">MTX_MinColIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im, unsigned *row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum element in the specified column and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal minimum elements, the first index from the beginning is returned.  <a href="#564e5943a56d59214dca1fb0a6562fbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#bcb89cc58bdcebb6f2915a275b2dfb3f">MTX_MinRowIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum element in the specified row and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal minimum elements, the first index from the beginning is returned.  <a href="#bcb89cc58bdcebb6f2915a275b2dfb3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#80d02d3d5716df9715c37260ae2335a6">MTX_MaxAbsColIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value, unsigned *row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute maximum element in the specified column and its index. If there are several equal maximum elements, the first index from the beginning is returned.  <a href="#80d02d3d5716df9715c37260ae2335a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#bc6cce1adef2f28a71eebcf8afc8005e">MTX_MaxAbsRowIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolue maximum element in the specified row and a its column index. If there are several equal maximum elements, the first index from the beginning is returned.  <a href="#bc6cce1adef2f28a71eebcf8afc8005e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7f2b7d690f4e04afd755881601e21a35">MTX_MinAbsColIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value, unsigned *row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute minimum element in the specified column and its index. If there are several equal minimum elements, the first index from the beginning is returned.  <a href="#7f2b7d690f4e04afd755881601e21a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9c93d5092d0c4ff012653d558437a072">MTX_MinAbsRowIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute minimum element in the specified row and its index. If there are several equal minimum elements, the first index from the beginning is returned.  <a href="#9c93d5092d0c4ff012653d558437a072"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#65936baf181f0ffb884d7200f0dbe309">MTX_MaxColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the maximum element in the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#65936baf181f0ffb884d7200f0dbe309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#44e709721d376c074682743e78dc2e8c">MTX_MaxRow</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the maximum element in the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#44e709721d376c074682743e78dc2e8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#0dfbe44652405759655588b5440a5f80">MTX_MinColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum element in the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#0dfbe44652405759655588b5440a5f80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#71db8c16d6ab0220ccf2dc834f49a1da">MTX_MinRow</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum element in the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#71db8c16d6ab0220ccf2dc834f49a1da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6cebb90ca48e79a134fd87295eec1c99">MTX_MaxAbsColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute maximum element in the specified column.  <a href="#6cebb90ca48e79a134fd87295eec1c99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#90dd92ff30aa45366a4a2b8b9f8284d4">MTX_MaxAbsRow</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute maximum element in the specified row.  <a href="#90dd92ff30aa45366a4a2b8b9f8284d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#69bca282e83e006f3f0e703f51e6ff4e">MTX_MinAbsColumn</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute minimum element in the specified column.  <a href="#69bca282e83e006f3f0e703f51e6ff4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#da418f1a614e0e83f6a3c02680c8320f">MTX_MinAbsRow</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute minimum element in the specified row.  <a href="#da418f1a614e0e83f6a3c02680c8320f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a6b4349848f4f5f22cfe293826740297">MTX_MaxAbsIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value, unsigned *row, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute maximum element for the entire matrix and its row and column index. If there are several equal maximum elements, the first index from the beginning is returned.  <a href="#a6b4349848f4f5f22cfe293826740297"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#141ad1a99fb363c68dc8d80eb5261cd2">MTX_MaxIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im, unsigned *row, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the maximum element for the entire matrix and its row and column index. If there are several equal maximum elements, the first index from the beginning is returned.  <a href="#141ad1a99fb363c68dc8d80eb5261cd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#45c35f88bf6a4a112c2f4f492f5429c5">MTX_MaxAbs</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute maximum element for the entire matrix.  <a href="#45c35f88bf6a4a112c2f4f492f5429c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#3127f02757fc64a27312dfaa60004111">MTX_Max</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the maximum element for the entire matrix.  <a href="#3127f02757fc64a27312dfaa60004111"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#aedab7f18d1890e8af1f4f8975638b29">MTX_MinAbsIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value, unsigned *row, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute minimum element for the entire matrix and its row and column index. If there are several equal minimum elements, the first index from the beginning is returned.  <a href="#aedab7f18d1890e8af1f4f8975638b29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#81a7712fe03beb7fdfc98ca5f12dd346">MTX_MinIndex</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im, unsigned *row, unsigned *col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum element for the entire matrix and its row and column index. If there are several equal minimum elements, the first index from the beginning is returned.  <a href="#81a7712fe03beb7fdfc98ca5f12dd346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#302c1fe15bf057ea4ec6bae40368c91c">MTX_MinAbs</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the absolute minimum element for the entire matrix.  <a href="#302c1fe15bf057ea4ec6bae40368c91c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#3b599a82775e964824d0a77cb01901ba">MTX_Min</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the minimum element for the entire matrix.  <a href="#3b599a82775e964824d0a77cb01901ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#b000b53b05db52703aa78e175ffaa0f0">MTX_ColumnRange</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the range of the data in the specified column. Range = MaxVal - MinVal. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#b000b53b05db52703aa78e175ffaa0f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9e025251f84e6afbf529bff33bca7a3d">MTX_RowRange</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the range of the data in the specified row. Range = MaxVal - MinVal. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#9e025251f84e6afbf529bff33bca7a3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#bea091a341271c96d8c206d298fa5931">MTX_Range</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the range of the data in the matrix. Range = MaxVal - MinVal. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#bea091a341271c96d8c206d298fa5931"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#8b9330a67f86ede94c604b8972462e99">MTX_ColumnSum</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sum for the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#8b9330a67f86ede94c604b8972462e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#88b1800f07fae16fb3dba3f6a09e5542">MTX_RowSum</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sum for the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#88b1800f07fae16fb3dba3f6a09e5542"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#134ad2e521e9e78b4c5ae0cad9a85ec6">MTX_Sum</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sum of the data in the matrix . If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#134ad2e521e9e78b4c5ae0cad9a85ec6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#dbbcaea49980ac311beb266f398a9c56">MTX_ColumnMean</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample mean for the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#dbbcaea49980ac311beb266f398a9c56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#37fc1eef89bb7bdad1fa1423a439a21d">MTX_RowMean</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample mean for the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#37fc1eef89bb7bdad1fa1423a439a21d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4e7015d8e5cc71a1b5a176db6c519410">MTX_Mean</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample mean for the matrix. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#4e7015d8e5cc71a1b5a176db6c519410"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#fd3793c6a45c4ee63140f196f0db9bfa">MTX_ColumnStdev</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample standard deviation for the specified column.  <a href="#fd3793c6a45c4ee63140f196f0db9bfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#fe7ff3a4d561036f7a442acdd6ca156b">MTX_RowStdev</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample standard deviation for the specified row.  <a href="#fe7ff3a4d561036f7a442acdd6ca156b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#68f959622826895bc2030d1bff25d64c">MTX_Stdev</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample standard deviation for the matrix.  <a href="#68f959622826895bc2030d1bff25d64c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ab930aa1c27f1c25f0310b68ae7c59ed">MTX_ColumnVar</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample variance for the specified column.  <a href="#ab930aa1c27f1c25f0310b68ae7c59ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#c92acfc9678d40b7ba80ecee84a1dd16">MTX_RowVar</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample variance for the specified row.  <a href="#c92acfc9678d40b7ba80ecee84a1dd16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4f74b95ca4fba8d584e12b2c64ce0004">MTX_Var</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample variance for the matrix.  <a href="#4f74b95ca4fba8d584e12b2c64ce0004"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#5f962b4af7f7608072b37545c004001a">MTX_ColumnNorm</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the norm of the specified column. If real, norm = sqrt( sum( val*val ) ). If complex, norm = sqrt( sum( val*conjugate(val) ) ).  <a href="#5f962b4af7f7608072b37545c004001a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#713fbd5b77cac26b329b05920aa9effe">MTX_RowNorm</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the norm of the specified row. If real, norm = sqrt( sum( val*val ) ). If complex, norm = sqrt( sum( val*conjugate(val) ) ).  <a href="#713fbd5b77cac26b329b05920aa9effe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4c31747ce9a93e5ad054745e615a8bac">MTX_Norm</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the norm of the matrix. If real, norm = sqrt( sum( val*val ) ). If complex, norm = sqrt( sum( val*conjugate(val) ) ).  <a href="#4c31747ce9a93e5ad054745e615a8bac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#b4e4506e0ff39b75072c18f73eead967">MTX_ColumnRMS</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample RMS value for the specified column.  <a href="#b4e4506e0ff39b75072c18f73eead967"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#64b9eb2e871e5e242d42d82de7cd0d9b">MTX_RowRMS</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample RMS value for the specified row.  <a href="#64b9eb2e871e5e242d42d82de7cd0d9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#18b677fe029a147dfbaa24b113bc5094">MTX_RMS</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample RMS value for the matrix.  <a href="#18b677fe029a147dfbaa24b113bc5094"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#d27cdf6dcca7a3ea431a2aa2fe117e9d">MTX_ColumnSkewness</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample skewness value for the specified column. The skewness is the third central moment divided by the cube of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#d27cdf6dcca7a3ea431a2aa2fe117e9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#934c04fe735a942c002d7f8cfa7ffa85">MTX_RowSkewness</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample skewness value for the specified row. The skewness is the third central moment divided by the cube of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#934c04fe735a942c002d7f8cfa7ffa85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#62216f8e8893f6bfbe2551862c0c2293">MTX_Skewness</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample skewness value for the matrix. The skewness is the third central moment divided by the cube of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#62216f8e8893f6bfbe2551862c0c2293"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#3bcbfa4dce285387bef662fda152d48d">MTX_ColumnKurtosis</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample kurtosis value for the specified column. The kurtosis is the fourth central moment divided by fourth power of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. To adjust the computed kurtosis value for bias, subtract 3 from the real component. Reference: <a href="http://en.wikipedia.org/wiki/Kurtosis.">http://en.wikipedia.org/wiki/Kurtosis.</a> Reference: <a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> (kurtosis proper is computed). g_2 = {m_4}{m_{2}^2} = {n\,{i=1}^n (x_i - {x})^4}{({i=1}^n (x_i - {x})^2)^2}.  <a href="#3bcbfa4dce285387bef662fda152d48d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7d51cbb229e346903cc11ea90d08cc4a">MTX_RowKurtosis</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned row, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample kurtosis value for the specified row. The kurtosis is the fourth central moment divided by fourth power of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. To adjust the computed kurtosis value for bias, subtract 3 from the real component. Reference: <a href="http://en.wikipedia.org/wiki/Kurtosis.">http://en.wikipedia.org/wiki/Kurtosis.</a> Reference: <a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> (kurtosis proper is computed). g_2 = {m_4}{m_{2}^2} = {n\,{i=1}^n (x_i - {x})^4}{({i=1}^n (x_i - {x})^2)^2}.  <a href="#7d51cbb229e346903cc11ea90d08cc4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#1b075018d430350e70d6886f4a41543b">MTX_Kurtosis</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the sample kurtosis value for the matrix. The kurtosis is the fourth central moment divided by fourth power of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. To adjust the computed kurtosis value for bias, subtract 3 from the real component. Reference: <a href="http://en.wikipedia.org/wiki/Kurtosis.">http://en.wikipedia.org/wiki/Kurtosis.</a> Reference: <a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> (kurtosis proper is computed). g_2 = {m_4}{m_{2}^2} = {n\,{i=1}^n (x_i - {x})^4}{({i=1}^n (x_i - {x})^2)^2}.  <a href="#1b075018d430350e70d6886f4a41543b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#db5070149dd5e61a7458c9e3149ebbd5">MTX_Trace</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the trace of M where M is a square matrix. Trace = Sum of diagonal elements. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#db5070149dd5e61a7458c9e3149ebbd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#31b3a3d10fb614e5e875960e39db2f27">MTX_Diagonal</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, <a class="el" href="struct_m_t_x.html">MTX</a> *D)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the diagonal elements of M into D as a column vector.  <a href="#31b3a3d10fb614e5e875960e39db2f27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#852236cd8aab10732d3611e4a734a509">MTX_SortAscending</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts each column of M in ascending order. If complex, sorts based on magnitude.  <a href="#852236cd8aab10732d3611e4a734a509"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#74c05a75393cbf724065ae4d53914f04">MTX_SortDescending</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts each column of M in descending order. If complex, sorts based on magnitude.  <a href="#74c05a75393cbf724065ae4d53914f04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6bcdb5c9dea604a38dc51858a2db367f">MTX_SortColumnAscending</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts a specific column in ascending order. If complex, sorts based on magnitude.  <a href="#6bcdb5c9dea604a38dc51858a2db367f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#69899586008b8c5f0a30770656a1a32c">MTX_SortColumnDescending</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts a specific column in descending order. If complex, sorts based on magnitude.  <a href="#69899586008b8c5f0a30770656a1a32c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#c7cb70acc2ca12b598f581f471b51470">MTX_SortColumnIndexed</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col, <a class="el" href="struct_m_t_x.html">MTX</a> *index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts a specific column in ascending order and fills a <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> column vector with the sorted index. The index vector will be resized if index-&gt;nrows != M-&gt;nrows If complex, sorts based on magnitude.  <a href="#c7cb70acc2ca12b598f581f471b51470"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7c51a6dc211682abafb3fd39c1fc0e2f">MTX_SortByColumn</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned col)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the entire matrix by a specific column. If complex, sorts based on magnitude.  <a href="#7c51a6dc211682abafb3fd39c1fc0e2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4e8870d8451de7220cbb90c9af8ead70">MTX_SaveCompressed</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves a matrix to the specified file path using a proprietary compressed format. ADVANCED EDITION ONLY!  <a href="#4e8870d8451de7220cbb90c9af8ead70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#29a2057f4e5e131161623aa429f8e51d">MTX_ReadCompressed</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const char *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a binary compressed matrix that was saved using the MTX_SaveCompressed function.  <a href="#29a2057f4e5e131161623aa429f8e51d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#1c5becc738f5b3596e37024f8d1de760">MTX_GetCompressedFileAttributes</a> (const char *path, unsigned *nrows, unsigned *ncols, BOOL *isReal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get attributes of the compressed file.  <a href="#1c5becc738f5b3596e37024f8d1de760"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#7b15d979a6fdc83761926dd4a6887a75">MTX_LoadAndSave</a> (const char *infilepath, const char *outfilepath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an ASCII matrix data file and save it using MTX_SaveCompressed. ADVANCED EDITION ONLY!  <a href="#7b15d979a6fdc83761926dd4a6887a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#e8c1f9642eb8f6f289373f47b92b463d">MTX_LoadAndSaveQuick</a> (const char *infilepath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an ASCII matrix data file and save it using MTX_SaveCompressed. This version saves the data to the same base filename and uses the .mtx extension. ADVANCED EDITION ONLY!  <a href="#e8c1f9642eb8f6f289373f47b92b463d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#aa038f5a95acda862b27e2df3b1b69a7">MTX_TimeWindow</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned timeColumn, const double startTime, const double duration, const double rolloverTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alter the matrix, M, so that its data is within the startTime to the startTime+duration and compensate for any rollovers in the time system (e.g. GPS time in seconds rolls over at 604800.0 s). This function assumes that time is one of the matrix columns and requires this index, the timeColumn.  <a href="#aa038f5a95acda862b27e2df3b1b69a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#4d90ffef79154f813218cdc7ff702a9d">MTX_TimeLimit</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M, const unsigned timeColumn, const double startTime, const double endTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alter the matrix, M, so that its data is within [startTime endTime]. This function assumes that time is one of the matrix columns and requires this index, the timeColumn.  <a href="#4d90ffef79154f813218cdc7ff702a9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a7047d72cc9145bcf3f2880546efcf10">MTX_TimeMatch</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const unsigned timeColumnA, <a class="el" href="struct_m_t_x.html">MTX</a> *B, const unsigned timeColumnB, const unsigned precision, const double rolloverTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function matches matrices in time with specified precision where time is a column of each matrix. This function also allows time to rollover at a specified interval.  <a href="#a7047d72cc9145bcf3f2880546efcf10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#72531a92fa9dae2f68f6d281d03b281b">MTX_Interpolate</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *A, const unsigned timeColumnA, <a class="el" href="struct_m_t_x.html">MTX</a> *B, const unsigned timeColumnB, const double maxInterpolationInterval, const double rolloverTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function interpolates Matrix B values by the times defined in the column in Matrix A. Time must be increasing but times can rollover with the specified rolloverTime.  <a href="#72531a92fa9dae2f68f6d281d03b281b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#bb23a99c6ed44a80832da948215a0a39">MTX_InvertInPlaceClosedForm</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inplace inverse of the matrix. Uses fast closed form solutions for: Only for: 1x1, 2x2, 3x3.  <a href="#bb23a99c6ed44a80832da948215a0a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#adaa01af1f8df39cc0f53eb7dd4b53da">MTX_InvertInPlace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inplace inverse of a postive definite matrix.  <a href="#adaa01af1f8df39cc0f53eb7dd4b53da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#86a6e065a28710748af619e9edfb6694">MTX_InvertInPlaceRobust</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *M)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perfroms an inplace inverse using Gaussian Elimination methods.  <a href="#86a6e065a28710748af619e9edfb6694"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#ac2bdaf1ce8f1fddc3f3424dcd841ac0">MTX_ColumnMovAvg</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned col, const unsigned lead, const unsigned lag, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a moving average using N lead samples and M lagging samples for the specified column and stores it in dst.  <a href="#ac2bdaf1ce8f1fddc3f3424dcd841ac0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6c7c4ea64431ca67ac5a7b98ec71fa3f">MTX_MovAvg</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const unsigned lead, const unsigned lag, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a moving average using N lead samples and M lagging samples for the matrix and stores it in dst.  <a href="#6c7c4ea64431ca67ac5a7b98ec71fa3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#afd6e8aab936565238b0a28449a6efa4">MTX_ATAInverse</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *A, <a class="el" href="struct_m_t_x.html">MTX</a> *InvATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes: InvATA = inverse( transpose(A) * A ).  <a href="#afd6e8aab936565238b0a28449a6efa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#840d7c4caa4939a741e38b1bd215b424">MTX_LowerTriangularInverseInplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inplace inverse of a unit lower triangular matrix. An example unit lower triangular matrix is: <br>
 A = [ 1 0 0; <br>
 -2 2 0; <br>
 4 -3 3 ]; with <br>
 inv(A) = [ 1 0 0; <br>
 1 1/2 0; <br>
 -1/3 1/2 1/3 ]; <br>
.  <a href="#840d7c4caa4939a741e38b1bd215b424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#6f4b69c198fe0c8c5089edb4d0b0e516">MTX_Det</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *M, double *re, double *im)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the determinatnt of the square matrix M. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set.  <a href="#6f4b69c198fe0c8c5089edb4d0b0e516"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#90b6a2e7c38543fb602d7f5269e53928">MTX_LUFactorization</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, BOOL *IsFullRank, <a class="el" href="struct_m_t_x.html">MTX</a> *P, <a class="el" href="struct_m_t_x.html">MTX</a> *L, <a class="el" href="struct_m_t_x.html">MTX</a> *U)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU factorization. Performs a factorization to produce a unit lower triangular matrix, L, an upper triangular matrix, U, and permutation matrix P so that P*X = L*U. P, L and U are copmuted correctly if IsFullRank is set to true.  <a href="#90b6a2e7c38543fb602d7f5269e53928"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#0982abfcf817c6be84dc7aa6cbb153b3">MTX_IndexedValues</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, const <a class="el" href="struct_m_t_x.html">MTX</a> *row_index, const <a class="el" href="struct_m_t_x.html">MTX</a> *col_index, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the elements of the matrix specified by the index vectors. The index vectors must be nx1 real vectors.  <a href="#0982abfcf817c6be84dc7aa6cbb153b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#76e14e7373a6ae07a97f9cb196623ce5">MTX_FFT</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the Fast Fourier Transform of each columns in the src matrix and store it in the dst matrix.  <a href="#76e14e7373a6ae07a97f9cb196623ce5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#9cbdd503359ad0f14cfa11777a7a9e7c">MTX_IFFT</a> (const <a class="el" href="struct_m_t_x.html">MTX</a> *src, <a class="el" href="struct_m_t_x.html">MTX</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inverse Fast Fourier Transform of each columns in the src matrix and store it in the dst matrix.  <a href="#9cbdd503359ad0f14cfa11777a7a9e7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#840cb00f37748bc4685d688ef8421649">MTX_FFT_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inplace Fast Fourier Transform of each column of the matrix.  <a href="#840cb00f37748bc4685d688ef8421649"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#c40cdb589f853e19709988d97cd4a067">MTX_IFFT_Inplace</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inplace inverse Fast Fourier Transform of each column of the matrix.  <a href="#c40cdb589f853e19709988d97cd4a067"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#63b7a1171f19ac324dc1387dd67f9846">MTX_Sin</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the sine of each element in the matrix. Assumes elements are radians.  <a href="#63b7a1171f19ac324dc1387dd67f9846"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#581d7291112c1646a5691b2649e3e0b1">MTX_Cos</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the cosine of each element in the matrix. Assumes elements are radians.  <a href="#581d7291112c1646a5691b2649e3e0b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cmatrix_8h.html#a1d3c21d32a67a69a3496578d905ad35">MTX_Colon</a> (<a class="el" href="struct_m_t_x.html">MTX</a> *dst, const double start, const double increment, const double end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a column vector [start:increment:end) beginning at start with step size of increment until less than or equal to end. Note that arguments must be real scalars. <br>
 e.g. a = 2:2:9 = [2; 4; 6; 8;] <br>
 e.g. b = 2:-2:-9 = [2; 0; -2; -4; -6; -9;] <br>
.  <a href="#a1d3c21d32a67a69a3496578d905ad35"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ef9448a648cc5dc20ed86430e1f75fca"></a><!-- doxytag: member="cmatrix.h::MTX_Abs" ref="ef9448a648cc5dc20ed86430e1f75fca" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Abs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute value of each element in the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efa26d0d4dbda6beca41e43be8f07f9e"></a><!-- doxytag: member="cmatrix.h::MTX_Add" ref="efa26d0d4dbda6beca41e43be8f07f9e" args="(MTX *A, const MTX *B, const MTX *C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Add           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add A = B+C. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b0fa9eb0aa5519d1d9d448c2077d1d3"></a><!-- doxytag: member="cmatrix.h::MTX_Add_Inplace" ref="8b0fa9eb0aa5519d1d9d448c2077d1d3" args="(MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Add_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add A += B, inplace. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca0fc95165b254b69e3a13838093597e"></a><!-- doxytag: member="cmatrix.h::MTX_Add_Scalar" ref="ca0fc95165b254b69e3a13838093597e" args="(MTX *M, const double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Add_Scalar           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a scalar double to matrix M, ie: M += 5. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd1ee574d085999cc0a6629d78444637"></a><!-- doxytag: member="cmatrix.h::MTX_Add_ScalarComplex" ref="fd1ee574d085999cc0a6629d78444637" args="(MTX *M, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Add_ScalarComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a scalar complex to matrix M, ie: M += (5 + 3i). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="05df54c4d4e3df1b518dc63046bdfe6d"></a><!-- doxytag: member="cmatrix.h::MTX_AddColumn" ref="05df54c4d4e3df1b518dc63046bdfe6d" args="(MTX *dst, const MTX *src, const unsigned src_col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_AddColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>src_col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a column to the Matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3c372bf5b556f75d810f8e3f87ad5c3"></a><!-- doxytag: member="cmatrix.h::MTX_Arctan" ref="f3c372bf5b556f75d810f8e3f87ad5c3" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Arctan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the arctan, atan(value) of each element in the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="afd6e8aab936565238b0a28449a6efa4"></a><!-- doxytag: member="cmatrix.h::MTX_ATAInverse" ref="afd6e8aab936565238b0a28449a6efa4" args="(const MTX *A, MTX *InvATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ATAInverse           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>InvATA</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes: InvATA = inverse( transpose(A) * A ). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c0e28fe06fa9cd39ef04753053b3dc5"></a><!-- doxytag: member="cmatrix.h::MTX_Calloc" ref="8c0e28fe06fa9cd39ef04753053b3dc5" args="(MTX *M, const unsigned nrows, const unsigned ncols, const BOOL isReal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Calloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>isReal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate matrix data (set to zero). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78d4e20464c3c74dbff4d1697073ba95"></a><!-- doxytag: member="cmatrix.h::MTX_Ceil" ref="78d4e20464c3c74dbff4d1697073ba95" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Ceil           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round the matrix elements to the nearest integers towards infinity. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a1d3c21d32a67a69a3496578d905ad35"></a><!-- doxytag: member="cmatrix.h::MTX_Colon" ref="a1d3c21d32a67a69a3496578d905ad35" args="(MTX *dst, const double start, const double increment, const double end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Colon           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a column vector [start:increment:end) beginning at start with step size of increment until less than or equal to end. Note that arguments must be real scalars. <br>
 e.g. a = 2:2:9 = [2; 4; 6; 8;] <br>
 e.g. b = 2:-2:-9 = [2; 0; -2; -4; -6; -9;] <br>
. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5848306f54988031751920501cdd855b"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnDiff" ref="5848306f54988031751920501cdd855b" args="(const MTX *M, MTX *Diff, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnDiff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Difference and approximte derivative for column col. The Diff is the column difference vector. diff = col[1:N-2] - col[0:N-1]. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3bcbfa4dce285387bef662fda152d48d"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnKurtosis" ref="3bcbfa4dce285387bef662fda152d48d" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnKurtosis           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample kurtosis value for the specified column. The kurtosis is the fourth central moment divided by fourth power of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. To adjust the computed kurtosis value for bias, subtract 3 from the real component. Reference: <a href="http://en.wikipedia.org/wiki/Kurtosis.">http://en.wikipedia.org/wiki/Kurtosis.</a> Reference: <a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> (kurtosis proper is computed). g_2 = {m_4}{m_{2}^2} = {n\,{i=1}^n (x_i - {x})^4}{({i=1}^n (x_i - {x})^2)^2}. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbbcaea49980ac311beb266f398a9c56"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnMean" ref="dbbcaea49980ac311beb266f398a9c56" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnMean           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample mean for the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac2bdaf1ce8f1fddc3f3424dcd841ac0"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnMovAvg" ref="ac2bdaf1ce8f1fddc3f3424dcd841ac0" args="(const MTX *src, const unsigned col, const unsigned lead, const unsigned lag, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnMovAvg           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>lead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes a moving average using N lead samples and M lagging samples for the specified column and stores it in dst. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f962b4af7f7608072b37545c004001a"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnNorm" ref="5f962b4af7f7608072b37545c004001a" args="(const MTX *M, const unsigned col, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnNorm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the norm of the specified column. If real, norm = sqrt( sum( val*val ) ). If complex, norm = sqrt( sum( val*conjugate(val) ) ). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b000b53b05db52703aa78e175ffaa0f0"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnRange" ref="b000b53b05db52703aa78e175ffaa0f0" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnRange           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the range of the data in the specified column. Range = MaxVal - MinVal. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4e4506e0ff39b75072c18f73eead967"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnRMS" ref="b4e4506e0ff39b75072c18f73eead967" args="(const MTX *M, const unsigned col, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnRMS           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample RMS value for the specified column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d27cdf6dcca7a3ea431a2aa2fe117e9d"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnSkewness" ref="d27cdf6dcca7a3ea431a2aa2fe117e9d" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnSkewness           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample skewness value for the specified column. The skewness is the third central moment divided by the cube of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd3793c6a45c4ee63140f196f0db9bfa"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnStdev" ref="fd3793c6a45c4ee63140f196f0db9bfa" args="(const MTX *M, const unsigned col, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnStdev           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample standard deviation for the specified column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b9330a67f86ede94c604b8972462e99"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnSum" ref="8b9330a67f86ede94c604b8972462e99" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnSum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sum for the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab930aa1c27f1c25f0310b68ae7c59ed"></a><!-- doxytag: member="cmatrix.h::MTX_ColumnVar" ref="ab930aa1c27f1c25f0310b68ae7c59ed" args="(const MTX *M, const unsigned col, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ColumnVar           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample variance for the specified column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d420707d92079f563175d8a1fdd975e"></a><!-- doxytag: member="cmatrix.h::MTX_Complex" ref="5d420707d92079f563175d8a1fdd975e" args="(MTX *M, const MTX *Re, const MTX *Im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Complex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matrix M = Re + Im*i, where Re and Im are real matrices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5bc010ce942348b8724a33693e11fe4"></a><!-- doxytag: member="cmatrix.h::MTX_Concatonate" ref="a5bc010ce942348b8724a33693e11fe4" args="(MTX *dst, const MTX *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Concatonate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combine two matrices with the same nrows, A becomes A|B,. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="db90a9ab8687d787963acca2afda47c9"></a><!-- doxytag: member="cmatrix.h::MTX_Conjugate" ref="db90a9ab8687d787963acca2afda47c9" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Conjugate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If M is a real matrix, nothing is done. If M is a complex matrix, the conjugate is set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3eaeffebef0b08a25abae680ab5e194"></a><!-- doxytag: member="cmatrix.h::MTX_ConvertComplexToImag" ref="b3eaeffebef0b08a25abae680ab5e194" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ConvertComplexToImag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a complex marix to a real matrix using only the imaginary component A = imag(B). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4a7af3c61343b4072798229ec8ce082"></a><!-- doxytag: member="cmatrix.h::MTX_ConvertComplexToReal" ref="d4a7af3c61343b4072798229ec8ce082" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ConvertComplexToReal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a complex marix to a real matrix using only the imaginary component A = real(B). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6671de01f24b261f2ef32ba3b89af252"></a><!-- doxytag: member="cmatrix.h::MTX_ConvertRealToComplex" ref="6671de01f24b261f2ef32ba3b89af252" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ConvertRealToComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a real matrix to a complex matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="61b2bf40f73795dc24cf8c1f3166388e"></a><!-- doxytag: member="cmatrix.h::MTX_Copy" ref="61b2bf40f73795dc24cf8c1f3166388e" args="(const MTX *src, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the src data to dst matrix, resize dst if possible &amp; necessary. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d72dffd498413e73a6e97a9013582ce"></a><!-- doxytag: member="cmatrix.h::MTX_CopyColumn" ref="0d72dffd498413e73a6e97a9013582ce" args="(const MTX *src, const unsigned col, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_CopyColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the src data in column col to dst matrix, resize dst if possible &amp; necessary. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a98c4dbe64c54fc019fd44d3da3b56f0"></a><!-- doxytag: member="cmatrix.h::MTX_CopyIntoColumnWiseVector" ref="a98c4dbe64c54fc019fd44d3da3b56f0" args="(const MTX *src, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_CopyIntoColumnWiseVector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the src matrix data [m cols x n rows] to dst vector [1 col x m*n rows], resize dst if possible &amp; necessary. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a5ffda4a5c28279215a30590dff8272"></a><!-- doxytag: member="cmatrix.h::MTX_CopyRow" ref="8a5ffda4a5c28279215a30590dff8272" args="(const MTX *src, const unsigned row, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_CopyRow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the src data in row, row, to dst matrix, resize dst if possible &amp; necessary. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b1cfeecc8d8168cbbb7ab6a136fb359"></a><!-- doxytag: member="cmatrix.h::MTX_CopyRowIntoAColumnMatrix" ref="1b1cfeecc8d8168cbbb7ab6a136fb359" args="(const MTX *src, const unsigned row, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_CopyRowIntoAColumnMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the src data in row 'row' (1xn) to dst matrix (nx1), resize dst if possible &amp; necessary. dst becomes (nx1). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="581d7291112c1646a5691b2649e3e0b1"></a><!-- doxytag: member="cmatrix.h::MTX_Cos" ref="581d7291112c1646a5691b2649e3e0b1" args="(MTX *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Cos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the cosine of each element in the matrix. Assumes elements are radians. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63911129bb62d4eed8fb3c4246f557a3"></a><!-- doxytag: member="cmatrix.h::MTX_Decrement" ref="63911129bb62d4eed8fb3c4246f557a3" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Decrement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtract 1.0 from all elements, e.g. M--. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f4b69c198fe0c8c5089edb4d0b0e516"></a><!-- doxytag: member="cmatrix.h::MTX_Det" ref="6f4b69c198fe0c8c5089edb4d0b0e516" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Det           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the determinatnt of the square matrix M. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="805f6a81b4d2f675294c3b1dea2b8749"></a><!-- doxytag: member="cmatrix.h::MTX_DetermineFileDelimiter" ref="805f6a81b4d2f675294c3b1dea2b8749" args="(const char *path, char *delimiter, BOOL *hasComment, char **comment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_DetermineFileDelimiter           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&nbsp;</td>
          <td class="paramname"> <em>hasComment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>comment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the matrix file delimiter and if a comment line is available. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>path</em>&nbsp;</td><td>
path to the input file </td></tr>
<tr><td valign="top"><em>delimiter</em>&nbsp;</td><td>
delimiter, 'b' is binary </td></tr>
<tr><td valign="top"><em>hasComment</em>&nbsp;</td><td>
BOOL to indicate if a comment line is present </td></tr>
<tr><td valign="top"><em>comment</em>&nbsp;</td><td>
pointer to a string to store the comment line, *comment memory must be freed later. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="69adb99d106c54790270a25559edd576"></a><!-- doxytag: member="cmatrix.h::MTX_DetermineFileSize" ref="69adb99d106c54790270a25559edd576" args="(const char *path, unsigned *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_DetermineFileSize           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the size of a file. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6db369ba46d7dbf1d962ad6bb3692e26"></a><!-- doxytag: member="cmatrix.h::MTX_DetermineNumberOfColumnsInDataString" ref="6db369ba46d7dbf1d962ad6bb3692e26" args="(const char *datastr, unsigned *ncols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_DetermineNumberOfColumnsInDataString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>datastr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>ncols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of columns in the data string provided. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="57ee434463838d4f4d2f27d6103b311c"></a><!-- doxytag: member="cmatrix.h::MTX_DetermineNumberOfColumnsInDataStringCplx" ref="57ee434463838d4f4d2f27d6103b311c" args="(const char *datastr, const char delimiter, unsigned *ncols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_DetermineNumberOfColumnsInDataStringCplx           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>datastr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>ncols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of columns in the complex data string provided. The delimiter is needed, 'w' indicates whitespace. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="31b3a3d10fb614e5e875960e39db2f27"></a><!-- doxytag: member="cmatrix.h::MTX_Diagonal" ref="31b3a3d10fb614e5e875960e39db2f27" args="(const MTX *M, MTX *D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Diagonal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>D</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the diagonal elements of M into D as a column vector. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b12b53fd5c489acaae7f392eb81ed3f"></a><!-- doxytag: member="cmatrix.h::MTX_Diff" ref="7b12b53fd5c489acaae7f392eb81ed3f" args="(const MTX *M, MTX *Diff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Diff           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Diff</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Difference and approximate derivative. The Diff matrix is composed of the column difference vectors. for(i=0:M-1){ diff_i = col_i[1:N-2] - col_i[0:N-1] }. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e51575e19fda85dfca222202db480f97"></a><!-- doxytag: member="cmatrix.h::MTX_Divide_Scalar" ref="e51575e19fda85dfca222202db480f97" args="(MTX *M, const double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Divide_Scalar           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Divide M by scaler double inplace, ie: M /= 5. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4918909ff04abb78de083ef2fae7f8ea"></a><!-- doxytag: member="cmatrix.h::MTX_Divide_ScalarComplex" ref="4918909ff04abb78de083ef2fae7f8ea" args="(MTX *M, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Divide_ScalarComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Divide M by scaler complex inplace, ie: M /= (5+3i). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78c213cc6635e7c588fe41df41049b6c"></a><!-- doxytag: member="cmatrix.h::MTX_DotDivide_Inplace" ref="78c213cc6635e7c588fe41df41049b6c" args="(MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_DotDivide_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dot divide A ./= B, inplace (A.data[col][row] = A.data[col][row]/B.data[col][row]). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="47e8962f4f001db852fd9b8b7eef1c7c"></a><!-- doxytag: member="cmatrix.h::MTX_DotMultiply_Inplace" ref="47e8962f4f001db852fd9b8b7eef1c7c" args="(MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_DotMultiply_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dot multiply A .*= B, inplace (A.data[col][row] = A.data[col][row]*B.data[col][row]). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc11a41223a37a68397e1ee5ba70a902"></a><!-- doxytag: member="cmatrix.h::MTX_Enable1x1MatricesForTreatmentAsScalars" ref="fc11a41223a37a68397e1ee5ba70a902" args="(BOOL enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Enable1x1MatricesForTreatmentAsScalars           </td>
          <td>(</td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to set if matrices that are single elements (1x1) are treated as scalars for math operations or whether the regular matrix rules apply. THIS IS ENABLED BY DEFAULT. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e3c2abe491dd922c5442482068d0ccf"></a><!-- doxytag: member="cmatrix.h::MTX_Exp" ref="2e3c2abe491dd922c5442482068d0ccf" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Exp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If real, computes the exp(value) of each element in the matrix. If complex, computes exp(M) = exp(real)*(cos(imag)+i*sin(imag)). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="76e14e7373a6ae07a97f9cb196623ce5"></a><!-- doxytag: member="cmatrix.h::MTX_FFT" ref="76e14e7373a6ae07a97f9cb196623ce5" args="(const MTX *src, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FFT           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the Fast Fourier Transform of each columns in the src matrix and store it in the dst matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="840cb00f37748bc4685d688ef8421649"></a><!-- doxytag: member="cmatrix.h::MTX_FFT_Inplace" ref="840cb00f37748bc4685d688ef8421649" args="(MTX *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FFT_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inplace Fast Fourier Transform of each column of the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e89a25fe578ca59bdd1ee8bdce5c2064"></a><!-- doxytag: member="cmatrix.h::MTX_Fill" ref="e89a25fe578ca59bdd1ee8bdce5c2064" args="(MTX *dst, const double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Fill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the matrix with the given value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0958fc561a0d20e38c5cfad41d7b6202"></a><!-- doxytag: member="cmatrix.h::MTX_FillColumn" ref="0958fc561a0d20e38c5cfad41d7b6202" args="(MTX *dst, const unsigned col, const double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FillColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the matrix column with the given value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6ef5cfa30ab3cb1ef1d0edbb7e398e8"></a><!-- doxytag: member="cmatrix.h::MTX_FillColumnComplex" ref="e6ef5cfa30ab3cb1ef1d0edbb7e398e8" args="(MTX *dst, const unsigned col, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FillColumnComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the matrix column with the given complex value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7b002d28b6c5264ae50b46deb705a1c"></a><!-- doxytag: member="cmatrix.h::MTX_FillComplex" ref="d7b002d28b6c5264ae50b46deb705a1c" args="(MTX *dst, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FillComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the matrix with the given complex value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="223916347f0c27d111450a6808665be8"></a><!-- doxytag: member="cmatrix.h::MTX_FillRow" ref="223916347f0c27d111450a6808665be8" args="(MTX *dst, const unsigned row, const double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FillRow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the matrix row with the given value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="936ddf8f308096b5d98bef51f61ed15e"></a><!-- doxytag: member="cmatrix.h::MTX_FillRowComplex" ref="936ddf8f308096b5d98bef51f61ed15e" args="(MTX *dst, const unsigned row, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FillRowComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the matrix row with the given complex value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15ddcb38e352700703ac7eb327f57cf5"></a><!-- doxytag: member="cmatrix.h::MTX_Fix" ref="15ddcb38e352700703ac7eb327f57cf5" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Fix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round the matrix elements of X to the nearest integers towards zero. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a32ad969b50d147306766da1d9f2880"></a><!-- doxytag: member="cmatrix.h::MTX_FlipColumn" ref="8a32ad969b50d147306766da1d9f2880" args="(MTX *M, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FlipColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverse the order of elements of a column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="043cd7939ae2a0145d29e21ed9ee5ccd"></a><!-- doxytag: member="cmatrix.h::MTX_FlipRow" ref="043cd7939ae2a0145d29e21ed9ee5ccd" args="(MTX *M, const unsigned row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_FlipRow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverse the order of elements of a row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="698185a8c08797a8ed89d573a017a3bf"></a><!-- doxytag: member="cmatrix.h::MTX_Floor" ref="698185a8c08797a8ed89d573a017a3bf" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Floor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round the matrix elements to the nearest integers towards minus infinity. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c2a6efafec90bc1ddc1c99185a18585a"></a><!-- doxytag: member="cmatrix.h::MTX_Free" ref="c2a6efafec90bc1ddc1c99185a18585a" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the matrix data from memory if dynamically allocated. Zero the struct members. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c5becc738f5b3596e37024f8d1de760"></a><!-- doxytag: member="cmatrix.h::MTX_GetCompressedFileAttributes" ref="1c5becc738f5b3596e37024f8d1de760" args="(const char *path, unsigned *nrows, unsigned *ncols, BOOL *isReal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_GetCompressedFileAttributes           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&nbsp;</td>
          <td class="paramname"> <em>isReal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get attributes of the compressed file. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a872a42ca5383a6dcf243335c4feaae"></a><!-- doxytag: member="cmatrix.h::MTX_Identity" ref="0a872a42ca5383a6dcf243335c4feaae" args="(MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Identity           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the matrix to an identity. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cbdd503359ad0f14cfa11777a7a9e7c"></a><!-- doxytag: member="cmatrix.h::MTX_IFFT" ref="9cbdd503359ad0f14cfa11777a7a9e7c" args="(const MTX *src, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_IFFT           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inverse Fast Fourier Transform of each columns in the src matrix and store it in the dst matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c40cdb589f853e19709988d97cd4a067"></a><!-- doxytag: member="cmatrix.h::MTX_IFFT_Inplace" ref="c40cdb589f853e19709988d97cd4a067" args="(MTX *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_IFFT_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inplace inverse Fast Fourier Transform of each column of the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="929a03f6126966d62bc89c20dee39bc6"></a><!-- doxytag: member="cmatrix.h::MTX_Imag" ref="929a03f6126966d62bc89c20dee39bc6" args="(const MTX *M, MTX *Im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Imag           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the imaginary component of matrix M. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fc9244847b0e502c0b6613e168ca9f8"></a><!-- doxytag: member="cmatrix.h::MTX_ImagColumn" ref="1fc9244847b0e502c0b6613e168ca9f8" args="(const MTX *M, const unsigned col, MTX *Im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ImagColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the imaginary component of column col of matrix M. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4180894f10dd78b873194d82d1f32be"></a><!-- doxytag: member="cmatrix.h::MTX_Increment" ref="a4180894f10dd78b873194d82d1f32be" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Increment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add +1.0 to all elements, e.g. M++. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0982abfcf817c6be84dc7aa6cbb153b3"></a><!-- doxytag: member="cmatrix.h::MTX_IndexedValues" ref="0982abfcf817c6be84dc7aa6cbb153b3" args="(const MTX *src, const MTX *row_index, const MTX *col_index, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_IndexedValues           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>col_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the elements of the matrix specified by the index vectors. The index vectors must be nx1 real vectors. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3857f486478bd797e93902df492ecf7f"></a><!-- doxytag: member="cmatrix.h::MTX_Init" ref="3857f486478bd797e93902df492ecf7f" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> matrix struct to appropriate zero values. This must always be called for proper operation! 
<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> matrix;
 <a class="code" href="cmatrix_8h.html#3857f486478bd797e93902df492ecf7f" title="Initialize a MTX matrix struct to appropriate zero values. This must always be called...">MTX_Init</a>( &amp;matrix );
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f0b76d92b803447ebd36d906759173e"></a><!-- doxytag: member="cmatrix.h::MTX_Initialize_MTXEngine" ref="3f0b76d92b803447ebd36d906759173e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Initialize_MTXEngine           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function must be called first by users of cmatrix! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e08bfd45679efbd7450137f38f8a423"></a><!-- doxytag: member="cmatrix.h::MTX_InsertColumn" ref="7e08bfd45679efbd7450137f38f8a423" args="(MTX *dst, const MTX *src, const unsigned dst_col, const unsigned src_col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_InsertColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>dst_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>src_col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
insert a column into another matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d51694bc9da56402208eae8cfecce739"></a><!-- doxytag: member="cmatrix.h::MTX_InsertSubMatrix" ref="d51694bc9da56402208eae8cfecce739" args="(MTX *dst, const MTX *src, const unsigned dst_row, const unsigned dst_col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_InsertSubMatrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>dst_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>dst_col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a submatrix (src) into dst, starting at indices dst(row,col). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="72531a92fa9dae2f68f6d281d03b281b"></a><!-- doxytag: member="cmatrix.h::MTX_Interpolate" ref="72531a92fa9dae2f68f6d281d03b281b" args="(MTX *A, const unsigned timeColumnA, MTX *B, const unsigned timeColumnB, const double maxInterpolationInterval, const double rolloverTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Interpolate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>timeColumnA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>timeColumnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>maxInterpolationInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>rolloverTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function interpolates Matrix B values by the times defined in the column in Matrix A. Time must be increasing but times can rollover with the specified rolloverTime. 
<p>
This function returns A and B with the same number of rows and time aligned time columns.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>A</em>&nbsp;</td><td>
The matrix with interpolation times </td></tr>
<tr><td valign="top"><em>timeColumnA</em>&nbsp;</td><td>
The zero based column index for matrix A </td></tr>
<tr><td valign="top"><em>B</em>&nbsp;</td><td>
The matrix to be interpolated </td></tr>
<tr><td valign="top"><em>timeColumnB</em>&nbsp;</td><td>
The zero based column index for matrix B </td></tr>
<tr><td valign="top"><em>maxInterpolationInterval</em>&nbsp;</td><td>
The largest interpolation interval allowed </td></tr>
<tr><td valign="top"><em>rolloverTime</em>&nbsp;</td><td>
The rollover time, e.g. 60 s for minute based timing, 0.0 means rollovers not allowed </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="adaa01af1f8df39cc0f53eb7dd4b53da"></a><!-- doxytag: member="cmatrix.h::MTX_InvertInPlace" ref="adaa01af1f8df39cc0f53eb7dd4b53da" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_InvertInPlace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inplace inverse of a postive definite matrix. 
<p>
The matrix is first tested to determine if it is a symmetric positive-definite matrix. If so, Cholesky decomposition is used to facilitate the inversion of a lower triangular matrix. If the matrix is not symmetric and positive-definite robust inversion using gaussing elimination is attempted.<p>
3x3 matrices or smaller dimensions are computed using MTX_InvertInPlaceClosedForm.<p>
If the matrix is singular, the original matrix is unchanged.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb23a99c6ed44a80832da948215a0a39"></a><!-- doxytag: member="cmatrix.h::MTX_InvertInPlaceClosedForm" ref="bb23a99c6ed44a80832da948215a0a39" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_InvertInPlaceClosedForm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inplace inverse of the matrix. Uses fast closed form solutions for: Only for: 1x1, 2x2, 3x3. 
<p>
If the matrix is singular, the original matrix is unchanged.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE if empty or has dimensions larger than 3x3, false if singular or not square </dd></dl>

</div>
</div><p>
<a class="anchor" name="86a6e065a28710748af619e9edfb6694"></a><!-- doxytag: member="cmatrix.h::MTX_InvertInPlaceRobust" ref="86a6e065a28710748af619e9edfb6694" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_InvertInPlaceRobust           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perfroms an inplace inverse using Gaussian Elimination methods. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="001dd2617c6417965e483d22b118f3f1"></a><!-- doxytag: member="cmatrix.h::MTX_isConformalForAddition" ref="001dd2617c6417965e483d22b118f3f1" args="(const MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_isConformalForAddition           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are matrices A &amp; B conformat for addition/subtraction, real + real. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac8e75465c8906f510f817e8da24fd37"></a><!-- doxytag: member="cmatrix.h::MTX_isConformalForMultiplication" ref="ac8e75465c8906f510f817e8da24fd37" args="(const MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_isConformalForMultiplication           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are matrices A &amp; B conformal for multiplication, real * real. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9fce4613f0766843fcb7e31c6ab74e3f"></a><!-- doxytag: member="cmatrix.h::MTX_IsEqual" ref="9fce4613f0766843fcb7e31c6ab74e3f" args="(const MTX *A, const MTX *B, const double tolerance, BOOL *isEqual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_IsEqual           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&nbsp;</td>
          <td class="paramname"> <em>isEqual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rest if A == B to within the specified tolerance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cffba9663e4c7bf7929dcd5e9467b6b"></a><!-- doxytag: member="cmatrix.h::MTX_isNull" ref="0cffba9663e4c7bf7929dcd5e9467b6b" args="(const MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_isNull           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a null matrix? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the matrix is null, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9455faec647442c0c3b4259cf9c57325"></a><!-- doxytag: member="cmatrix.h::MTX_isSameSize" ref="9455faec647442c0c3b4259cf9c57325" args="(const MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_isSameSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
are A and B the same size? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5731da64e9d26d27c279552e02d21f4"></a><!-- doxytag: member="cmatrix.h::MTX_isSquare" ref="b5731da64e9d26d27c279552e02d21f4" args="(const MTX *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_isSquare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a square matrix? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b075018d430350e70d6886f4a41543b"></a><!-- doxytag: member="cmatrix.h::MTX_Kurtosis" ref="1b075018d430350e70d6886f4a41543b" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Kurtosis           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample kurtosis value for the matrix. The kurtosis is the fourth central moment divided by fourth power of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. To adjust the computed kurtosis value for bias, subtract 3 from the real component. Reference: <a href="http://en.wikipedia.org/wiki/Kurtosis.">http://en.wikipedia.org/wiki/Kurtosis.</a> Reference: <a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> (kurtosis proper is computed). g_2 = {m_4}{m_{2}^2} = {n\,{i=1}^n (x_i - {x})^4}{({i=1}^n (x_i - {x})^2)^2}. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a6c590e5318f16990164f4364f8248c2"></a><!-- doxytag: member="cmatrix.h::MTX_Ln" ref="a6c590e5318f16990164f4364f8248c2" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Ln           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the natural logarithm, ln(value) of each element in the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b15d979a6fdc83761926dd4a6887a75"></a><!-- doxytag: member="cmatrix.h::MTX_LoadAndSave" ref="7b15d979a6fdc83761926dd4a6887a75" args="(const char *infilepath, const char *outfilepath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_LoadAndSave           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>infilepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>outfilepath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read an ASCII matrix data file and save it using MTX_SaveCompressed. ADVANCED EDITION ONLY! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8c1f9642eb8f6f289373f47b92b463d"></a><!-- doxytag: member="cmatrix.h::MTX_LoadAndSaveQuick" ref="e8c1f9642eb8f6f289373f47b92b463d" args="(const char *infilepath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_LoadAndSaveQuick           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>infilepath</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read an ASCII matrix data file and save it using MTX_SaveCompressed. This version saves the data to the same base filename and uses the .mtx extension. ADVANCED EDITION ONLY! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="840d7c4caa4939a741e38b1bd215b424"></a><!-- doxytag: member="cmatrix.h::MTX_LowerTriangularInverseInplace" ref="840d7c4caa4939a741e38b1bd215b424" args="(MTX *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_LowerTriangularInverseInplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the inplace inverse of a unit lower triangular matrix. An example unit lower triangular matrix is: <br>
 A = [ 1 0 0; <br>
 -2 2 0; <br>
 4 -3 3 ]; with <br>
 inv(A) = [ 1 0 0; <br>
 1 1/2 0; <br>
 -1/3 1/2 1/3 ]; <br>
. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90b6a2e7c38543fb602d7f5269e53928"></a><!-- doxytag: member="cmatrix.h::MTX_LUFactorization" ref="90b6a2e7c38543fb602d7f5269e53928" args="(const MTX *src, BOOL *IsFullRank, MTX *P, MTX *L, MTX *U)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_LUFactorization           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&nbsp;</td>
          <td class="paramname"> <em>IsFullRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>U</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
LU factorization. Performs a factorization to produce a unit lower triangular matrix, L, an upper triangular matrix, U, and permutation matrix P so that P*X = L*U. P, L and U are copmuted correctly if IsFullRank is set to true. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="519d759c2913aefffa7d3c7c138dd30f"></a><!-- doxytag: member="cmatrix.h::MTX_Magnitude" ref="519d759c2913aefffa7d3c7c138dd30f" args="(const MTX *M, MTX *Magnitude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Magnitude           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Magnitude</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If M is a real matrix, Magnitude is a copy. If M is a complex matrix, Magnitude is a real matrix = sqrt( re*re + im*im ). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="285ed3f66b2a522a6c5f0de4b6c421cb"></a><!-- doxytag: member="cmatrix.h::MTX_Malloc" ref="285ed3f66b2a522a6c5f0de4b6c421cb" args="(MTX *M, const unsigned nrows, const unsigned ncols, const BOOL isReal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Malloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>isReal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate matrix data (not set to zero). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3127f02757fc64a27312dfaa60004111"></a><!-- doxytag: member="cmatrix.h::MTX_Max" ref="3127f02757fc64a27312dfaa60004111" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Max           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the maximum element for the entire matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="45c35f88bf6a4a112c2f4f492f5429c5"></a><!-- doxytag: member="cmatrix.h::MTX_MaxAbs" ref="45c35f88bf6a4a112c2f4f492f5429c5" args="(const MTX *M, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxAbs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute maximum element for the entire matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80d02d3d5716df9715c37260ae2335a6"></a><!-- doxytag: member="cmatrix.h::MTX_MaxAbsColIndex" ref="80d02d3d5716df9715c37260ae2335a6" args="(const MTX *M, const unsigned col, double *value, unsigned *row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxAbsColIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute maximum element in the specified column and its index. If there are several equal maximum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cebb90ca48e79a134fd87295eec1c99"></a><!-- doxytag: member="cmatrix.h::MTX_MaxAbsColumn" ref="6cebb90ca48e79a134fd87295eec1c99" args="(const MTX *M, const unsigned col, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxAbsColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute maximum element in the specified column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a6b4349848f4f5f22cfe293826740297"></a><!-- doxytag: member="cmatrix.h::MTX_MaxAbsIndex" ref="a6b4349848f4f5f22cfe293826740297" args="(const MTX *M, double *value, unsigned *row, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxAbsIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute maximum element for the entire matrix and its row and column index. If there are several equal maximum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90dd92ff30aa45366a4a2b8b9f8284d4"></a><!-- doxytag: member="cmatrix.h::MTX_MaxAbsRow" ref="90dd92ff30aa45366a4a2b8b9f8284d4" args="(const MTX *M, const unsigned row, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxAbsRow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute maximum element in the specified row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc6cce1adef2f28a71eebcf8afc8005e"></a><!-- doxytag: member="cmatrix.h::MTX_MaxAbsRowIndex" ref="bc6cce1adef2f28a71eebcf8afc8005e" args="(const MTX *M, const unsigned row, double *value, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxAbsRowIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolue maximum element in the specified row and a its column index. If there are several equal maximum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14ac174801d052881666d4cb208f1f2c"></a><!-- doxytag: member="cmatrix.h::MTX_MaxColIndex" ref="14ac174801d052881666d4cb208f1f2c" args="(const MTX *M, const unsigned col, double *re, double *im, unsigned *row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxColIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the maximum element in the specified column and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal maximum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="65936baf181f0ffb884d7200f0dbe309"></a><!-- doxytag: member="cmatrix.h::MTX_MaxColumn" ref="65936baf181f0ffb884d7200f0dbe309" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the maximum element in the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="141ad1a99fb363c68dc8d80eb5261cd2"></a><!-- doxytag: member="cmatrix.h::MTX_MaxIndex" ref="141ad1a99fb363c68dc8d80eb5261cd2" args="(const MTX *M, double *re, double *im, unsigned *row, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the maximum element for the entire matrix and its row and column index. If there are several equal maximum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="44e709721d376c074682743e78dc2e8c"></a><!-- doxytag: member="cmatrix.h::MTX_MaxRow" ref="44e709721d376c074682743e78dc2e8c" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxRow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the maximum element in the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="00609631e59fb1d897c30c8459ec9c56"></a><!-- doxytag: member="cmatrix.h::MTX_MaxRowIndex" ref="00609631e59fb1d897c30c8459ec9c56" args="(const MTX *M, const unsigned row, double *re, double *im, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MaxRowIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the maximum element in the specified row and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal maximum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e7015d8e5cc71a1b5a176db6c519410"></a><!-- doxytag: member="cmatrix.h::MTX_Mean" ref="4e7015d8e5cc71a1b5a176db6c519410" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Mean           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample mean for the matrix. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b599a82775e964824d0a77cb01901ba"></a><!-- doxytag: member="cmatrix.h::MTX_Min" ref="3b599a82775e964824d0a77cb01901ba" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Min           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum element for the entire matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="302c1fe15bf057ea4ec6bae40368c91c"></a><!-- doxytag: member="cmatrix.h::MTX_MinAbs" ref="302c1fe15bf057ea4ec6bae40368c91c" args="(const MTX *M, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinAbs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute minimum element for the entire matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f2b7d690f4e04afd755881601e21a35"></a><!-- doxytag: member="cmatrix.h::MTX_MinAbsColIndex" ref="7f2b7d690f4e04afd755881601e21a35" args="(const MTX *M, const unsigned col, double *value, unsigned *row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinAbsColIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute minimum element in the specified column and its index. If there are several equal minimum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69bca282e83e006f3f0e703f51e6ff4e"></a><!-- doxytag: member="cmatrix.h::MTX_MinAbsColumn" ref="69bca282e83e006f3f0e703f51e6ff4e" args="(const MTX *M, const unsigned col, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinAbsColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute minimum element in the specified column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aedab7f18d1890e8af1f4f8975638b29"></a><!-- doxytag: member="cmatrix.h::MTX_MinAbsIndex" ref="aedab7f18d1890e8af1f4f8975638b29" args="(const MTX *M, double *value, unsigned *row, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinAbsIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute minimum element for the entire matrix and its row and column index. If there are several equal minimum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="da418f1a614e0e83f6a3c02680c8320f"></a><!-- doxytag: member="cmatrix.h::MTX_MinAbsRow" ref="da418f1a614e0e83f6a3c02680c8320f" args="(const MTX *M, const unsigned row, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinAbsRow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute minimum element in the specified row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c93d5092d0c4ff012653d558437a072"></a><!-- doxytag: member="cmatrix.h::MTX_MinAbsRowIndex" ref="9c93d5092d0c4ff012653d558437a072" args="(const MTX *M, const unsigned row, double *value, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinAbsRowIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the absolute minimum element in the specified row and its index. If there are several equal minimum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="564e5943a56d59214dca1fb0a6562fbf"></a><!-- doxytag: member="cmatrix.h::MTX_MinColIndex" ref="564e5943a56d59214dca1fb0a6562fbf" args="(const MTX *M, const unsigned col, double *re, double *im, unsigned *row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinColIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum element in the specified column and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal minimum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0dfbe44652405759655588b5440a5f80"></a><!-- doxytag: member="cmatrix.h::MTX_MinColumn" ref="0dfbe44652405759655588b5440a5f80" args="(const MTX *M, const unsigned col, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum element in the specified column. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="81a7712fe03beb7fdfc98ca5f12dd346"></a><!-- doxytag: member="cmatrix.h::MTX_MinIndex" ref="81a7712fe03beb7fdfc98ca5f12dd346" args="(const MTX *M, double *re, double *im, unsigned *row, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum element for the entire matrix and its row and column index. If there are several equal minimum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="71db8c16d6ab0220ccf2dc834f49a1da"></a><!-- doxytag: member="cmatrix.h::MTX_MinRow" ref="71db8c16d6ab0220ccf2dc834f49a1da" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinRow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum element in the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcb89cc58bdcebb6f2915a275b2dfb3f"></a><!-- doxytag: member="cmatrix.h::MTX_MinRowIndex" ref="bcb89cc58bdcebb6f2915a275b2dfb3f" args="(const MTX *M, const unsigned row, double *re, double *im, unsigned *col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MinRowIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the minimum element in the specified row and its index. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. If there are several equal minimum elements, the first index from the beginning is returned. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c7c4ea64431ca67ac5a7b98ec71fa3f"></a><!-- doxytag: member="cmatrix.h::MTX_MovAvg" ref="6c7c4ea64431ca67ac5a7b98ec71fa3f" args="(const MTX *src, const unsigned lead, const unsigned lag, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_MovAvg           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>lead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes a moving average using N lead samples and M lagging samples for the matrix and stores it in dst. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6908c105fbe0c79dd831abc3dfa52df2"></a><!-- doxytag: member="cmatrix.h::MTX_Multiply" ref="6908c105fbe0c79dd831abc3dfa52df2" args="(MTX *A, const MTX *B, const MTX *C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Multiply           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply A = B*C. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f7f7b6909be3ef37ccd0763933f4ca8"></a><!-- doxytag: member="cmatrix.h::MTX_Multiply_Scalar" ref="4f7f7b6909be3ef37ccd0763933f4ca8" args="(MTX *M, const double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Multiply_Scalar           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply M with a double scalar inplace, ie: M *= 5. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="669d1d7991e566150b5b48cade33599f"></a><!-- doxytag: member="cmatrix.h::MTX_Multiply_ScalarComplex" ref="669d1d7991e566150b5b48cade33599f" args="(MTX *M, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Multiply_ScalarComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply M with a complex scalar inplace, ie: M *= (5+3i). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c31747ce9a93e5ad054745e615a8bac"></a><!-- doxytag: member="cmatrix.h::MTX_Norm" ref="4c31747ce9a93e5ad054745e615a8bac" args="(const MTX *M, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Norm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the norm of the matrix. If real, norm = sqrt( sum( val*val ) ). If complex, norm = sqrt( sum( val*conjugate(val) ) ). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="93db857a6b2a3ca31ba0a3ab2533cf31"></a><!-- doxytag: member="cmatrix.h::MTX_Phase" ref="93db857a6b2a3ca31ba0a3ab2533cf31" args="(const MTX *M, MTX *Phase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Phase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Phase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If M is a real matrix, Phase is a zero matrix. If M is a complex matrix, Phase is a real matrix = atan2(im,re). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3bcaf5747f7364c95fb4169f7d186547"></a><!-- doxytag: member="cmatrix.h::MTX_PostMultiply_Inplace" ref="3bcaf5747f7364c95fb4169f7d186547" args="(MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PostMultiply_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply A = A*B, inplace. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6ea71b580baa3c667f979c7ed902d3f"></a><!-- doxytag: member="cmatrix.h::MTX_Pow" ref="f6ea71b580baa3c667f979c7ed902d3f" args="(const MTX *src, MTX *dst, const double power_re, const double power_im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Pow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>power_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>power_im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raise all elements in src^(power_re + power_im*i) and store in dst. If power is just real, power_im = 0.0. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9d281c72f9ad9b27683682e0ac37ff6b"></a><!-- doxytag: member="cmatrix.h::MTX_PowInplace" ref="9d281c72f9ad9b27683682e0ac37ff6b" args="(MTX *src, const double power_re, const double power_im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PowInplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>power_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>power_im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raise all elements in src^(power_re + power_im*i). If power is just real, power_im = 0.0. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea1ded94d6ec84f3f47c0cfbfbaa9248"></a><!-- doxytag: member="cmatrix.h::MTX_PreMultiply_Inplace" ref="ea1ded94d6ec84f3f47c0cfbfbaa9248" args="(MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PreMultiply_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply A = B*A, inplace. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f2c4e8f49c1f7bf7165638284c195a6"></a><!-- doxytag: member="cmatrix.h::MTX_Print" ref="7f2c4e8f49c1f7bf7165638284c195a6" args="(const MTX *M, const char *path, const unsigned width, const unsigned precision, const BOOL append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>append</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to a file with specifed width and precision. MTX_PrintAutoWidth is recommended over this function, "%'blank''-'width.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="007814c53f6007fa7318293532d3ab90"></a><!-- doxytag: member="cmatrix.h::MTX_Print_ToBuffer" ref="007814c53f6007fa7318293532d3ab90" args="(const MTX *M, char *buffer, const unsigned maxlength, const unsigned width, const unsigned precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Print_ToBuffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to a buffer of maxlength with specifed width and precision. MTX_PrintAutoWidth is recommended over this function, "%'blank''-'width.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="00e65dc76850178b7dd0bc8ebb8dcc52"></a><!-- doxytag: member="cmatrix.h::MTX_PrintAutoWidth" ref="00e65dc76850178b7dd0bc8ebb8dcc52" args="(const MTX *M, const char *path, const unsigned precision, const BOOL append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PrintAutoWidth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>append</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to a file with automatically determined column width. and the specified precision, uses "%'blank''-'autowidth.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd7a6829c5fde0020dc231a82e2ee33b"></a><!-- doxytag: member="cmatrix.h::MTX_PrintAutoWidth_ToBuffer" ref="cd7a6829c5fde0020dc231a82e2ee33b" args="(const MTX *M, char *buffer, const unsigned maxlength, const unsigned precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PrintAutoWidth_ToBuffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to a buffer of maxlenth with automatically determined column width. and the specified precision, uses "%'blank''-'autowidth.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="954215ef6e13791b8eeaa3688876c23a"></a><!-- doxytag: member="cmatrix.h::MTX_PrintDelimited" ref="954215ef6e13791b8eeaa3688876c23a" args="(const MTX *M, const char *path, const unsigned precision, const char delimiter, const BOOL append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PrintDelimited           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>append</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to a file with specifed precision and delimiter. Use MTX_PrintAutoWidth if print using whitespace as a delimiter is required, uses "%.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4914542f51f70387aa15f8d3edb22c58"></a><!-- doxytag: member="cmatrix.h::MTX_PrintDelimited_ToBuffer" ref="4914542f51f70387aa15f8d3edb22c58" args="(const MTX *M, char *buffer, const unsigned maxlength, const unsigned precision, const char delimiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PrintDelimited_ToBuffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>delimiter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to a file with specifed precision and delimiter. Use MTX_PrintAutoWidth if print using whitespace as a delimiter is required, uses "%.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ac92ccc98baa6280f29e4a19456dc7a"></a><!-- doxytag: member="cmatrix.h::MTX_PrintRowToString" ref="8ac92ccc98baa6280f29e4a19456dc7a" args="(const MTX *M, const unsigned row, char *buffer, const unsigned maxlength, const int width, const int precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PrintRowToString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>precision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a row to a string buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac9c6054cce8871bdcf9c77091d240b8"></a><!-- doxytag: member="cmatrix.h::MTX_PrintStdoutAutoWidth" ref="ac9c6054cce8871bdcf9c77091d240b8" args="(const MTX *M, const unsigned precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_PrintStdoutAutoWidth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the matrix to stdout with automatically determined column width. and the specified precision, uses "%'blank''-'autowidth.precision'g'". 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bea091a341271c96d8c206d298fa5931"></a><!-- doxytag: member="cmatrix.h::MTX_Range" ref="bea091a341271c96d8c206d298fa5931" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the range of the data in the matrix. Range = MaxVal - MinVal. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29a2057f4e5e131161623aa429f8e51d"></a><!-- doxytag: member="cmatrix.h::MTX_ReadCompressed" ref="29a2057f4e5e131161623aa429f8e51d" args="(MTX *M, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ReadCompressed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a binary compressed matrix that was saved using the MTX_SaveCompressed function. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a7ea41b13f45934ed3ee4a6410856880"></a><!-- doxytag: member="cmatrix.h::MTX_ReadFromFile" ref="a7ea41b13f45934ed3ee4a6410856880" args="(MTX *M, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ReadFromFile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read either a real or complex matrix from a file (ASCII formatted, any common delimiters). This function will also read in <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> BINARY formatted files. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="534aeb533410b9bdecb38d938df28da0"></a><!-- doxytag: member="cmatrix.h::MTX_ReadFromFileRealOnly" ref="534aeb533410b9bdecb38d938df28da0" args="(MTX *M, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ReadFromFileRealOnly           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a real-only matrix from a file (ASCII formatted, any common delimiters). This function will also read in <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> BINARY formatted files. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b833a251fc8357281d00bf53bdb4fe1f"></a><!-- doxytag: member="cmatrix.h::MTX_Real" ref="b833a251fc8357281d00bf53bdb4fe1f" args="(const MTX *M, MTX *Re)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Real           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Re</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the real component of matrix M. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="79c5d6c0a69860807652c170718c90c7"></a><!-- doxytag: member="cmatrix.h::MTX_RealColumn" ref="79c5d6c0a69860807652c170718c90c7" args="(const MTX *M, const unsigned col, MTX *Re)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RealColumn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Re</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the real component of column col of matrix M. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9238b3c6825a054ce85788eb5d24963"></a><!-- doxytag: member="cmatrix.h::MTX_Redim" ref="c9238b3c6825a054ce85788eb5d24963" args="(MTX *dst, const unsigned nrows, const unsigned ncols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Redim           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>ncols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Redimension the matrix, original data is saved in place, new data is set to zero. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5c1a441658ba66ebcace32cd1a13ced"></a><!-- doxytag: member="cmatrix.h::MTX_RemoveColumn" ref="a5c1a441658ba66ebcace32cd1a13ced" args="(MTX *M, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RemoveColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a single column from the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aaf7d19d52936661dc01b7a234e2f194"></a><!-- doxytag: member="cmatrix.h::MTX_RemoveColumnsAfterIndex" ref="aaf7d19d52936661dc01b7a234e2f194" args="(MTX *dst, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RemoveColumnsAfterIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
remove all the columns 'after' the column index given. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01277701346e92df67a9b163396b4e42"></a><!-- doxytag: member="cmatrix.h::MTX_Resize" ref="01277701346e92df67a9b163396b4e42" args="(MTX *dst, const unsigned nrows, const unsigned ncols, const BOOL isReal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Resize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>isReal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize the matrix, original data is lost, new data is set to zero, must specify if the matrix is real or complex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18b677fe029a147dfbaa24b113bc5094"></a><!-- doxytag: member="cmatrix.h::MTX_RMS" ref="18b677fe029a147dfbaa24b113bc5094" args="(const MTX *M, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RMS           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample RMS value for the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb94314d49118919c8893008ddabd84e"></a><!-- doxytag: member="cmatrix.h::MTX_Round" ref="cb94314d49118919c8893008ddabd84e" args="(MTX *M, const unsigned precision)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Round           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round the matrix elements to the specified precision.<br>
 e.g. precision = 0 1.8 -&gt; 2<br>
 e.g. precision = 1, 1.45 -&gt; 1.5<br>
 e.g. precision = 2 1.456 -&gt; 1.46<br>
 e.g. precision = 3, 1.4566 -&gt; 1.457<br>
. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d51cbb229e346903cc11ea90d08cc4a"></a><!-- doxytag: member="cmatrix.h::MTX_RowKurtosis" ref="7d51cbb229e346903cc11ea90d08cc4a" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowKurtosis           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample kurtosis value for the specified row. The kurtosis is the fourth central moment divided by fourth power of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. To adjust the computed kurtosis value for bias, subtract 3 from the real component. Reference: <a href="http://en.wikipedia.org/wiki/Kurtosis.">http://en.wikipedia.org/wiki/Kurtosis.</a> Reference: <a href="http://mathworld.wolfram.com/Kurtosis.html">http://mathworld.wolfram.com/Kurtosis.html</a> (kurtosis proper is computed). g_2 = {m_4}{m_{2}^2} = {n\,{i=1}^n (x_i - {x})^4}{({i=1}^n (x_i - {x})^2)^2}. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="37fc1eef89bb7bdad1fa1423a439a21d"></a><!-- doxytag: member="cmatrix.h::MTX_RowMean" ref="37fc1eef89bb7bdad1fa1423a439a21d" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowMean           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample mean for the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="713fbd5b77cac26b329b05920aa9effe"></a><!-- doxytag: member="cmatrix.h::MTX_RowNorm" ref="713fbd5b77cac26b329b05920aa9effe" args="(const MTX *M, const unsigned row, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowNorm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the norm of the specified row. If real, norm = sqrt( sum( val*val ) ). If complex, norm = sqrt( sum( val*conjugate(val) ) ). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e025251f84e6afbf529bff33bca7a3d"></a><!-- doxytag: member="cmatrix.h::MTX_RowRange" ref="9e025251f84e6afbf529bff33bca7a3d" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowRange           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the range of the data in the specified row. Range = MaxVal - MinVal. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64b9eb2e871e5e242d42d82de7cd0d9b"></a><!-- doxytag: member="cmatrix.h::MTX_RowRMS" ref="64b9eb2e871e5e242d42d82de7cd0d9b" args="(const MTX *M, const unsigned row, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowRMS           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample RMS value for the specified row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="934c04fe735a942c002d7f8cfa7ffa85"></a><!-- doxytag: member="cmatrix.h::MTX_RowSkewness" ref="934c04fe735a942c002d7f8cfa7ffa85" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowSkewness           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample skewness value for the specified row. The skewness is the third central moment divided by the cube of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe7ff3a4d561036f7a442acdd6ca156b"></a><!-- doxytag: member="cmatrix.h::MTX_RowStdev" ref="fe7ff3a4d561036f7a442acdd6ca156b" args="(const MTX *M, const unsigned row, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowStdev           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample standard deviation for the specified row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88b1800f07fae16fb3dba3f6a09e5542"></a><!-- doxytag: member="cmatrix.h::MTX_RowSum" ref="88b1800f07fae16fb3dba3f6a09e5542" args="(const MTX *M, const unsigned row, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowSum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sum for the specified row. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c92acfc9678d40b7ba80ecee84a1dd16"></a><!-- doxytag: member="cmatrix.h::MTX_RowVar" ref="c92acfc9678d40b7ba80ecee84a1dd16" args="(const MTX *M, const unsigned row, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_RowVar           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample variance for the specified row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e8870d8451de7220cbb90c9af8ead70"></a><!-- doxytag: member="cmatrix.h::MTX_SaveCompressed" ref="4e8870d8451de7220cbb90c9af8ead70" args="(const MTX *M, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SaveCompressed           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves a matrix to the specified file path using a proprietary compressed format. ADVANCED EDITION ONLY! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e2cffbbe72f6b8048cebc8a197ac76f"></a><!-- doxytag: member="cmatrix.h::MTX_SetComment" ref="8e2cffbbe72f6b8048cebc8a197ac76f" args="(MTX *M, const char *comment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SetComment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the matrix comment string. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff98269455216bc2fd7fb540f1d70ab9"></a><!-- doxytag: member="cmatrix.h::MTX_SetComplexColumn" ref="ff98269455216bc2fd7fb540f1d70ab9" args="(MTX *M, const unsigned col, const MTX *Re, const MTX *Im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SetComplexColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>Im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the specified column in Matrix M to Re + Im*i, where Re and Im are real matrices. The dimensions of M must already be valid. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8b1520cf96455a72ba1f4d95215bb02"></a><!-- doxytag: member="cmatrix.h::MTX_SetComplexValue" ref="e8b1520cf96455a72ba1f4d95215bb02" args="(MTX *M, const unsigned row, const unsigned col, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SetComplexValue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a complex value in the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5edba86cc03ecfcd32e49d3ef48280bc"></a><!-- doxytag: member="cmatrix.h::MTX_SetFromMatrixString" ref="5edba86cc03ecfcd32e49d3ef48280bc" args="(MTX *M, const char *strMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SetFromMatrixString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>strMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the matrix from a matrix string. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9b840d63b0107b08d82ba52af45a6b37"></a><!-- doxytag: member="cmatrix.h::MTX_SetFromStaticMatrix" ref="9b840d63b0107b08d82ba52af45a6b37" args="(MTX *dst, const double mat[], const unsigned nrows, const unsigned ncols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SetFromStaticMatrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>mat</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>ncols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the dst matrix from the static 'c' style matrix indexed by mat[i*ncols + j]. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b0f9acaf54cf4979cd5eeeeded96a7d"></a><!-- doxytag: member="cmatrix.h::MTX_SetValue" ref="8b0f9acaf54cf4979cd5eeeeded96a7d" args="(MTX *M, const unsigned row, const unsigned col, const double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SetValue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a scalar value in the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63b7a1171f19ac324dc1387dd67f9846"></a><!-- doxytag: member="cmatrix.h::MTX_Sin" ref="63b7a1171f19ac324dc1387dd67f9846" args="(MTX *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Sin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the sine of each element in the matrix. Assumes elements are radians. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="62216f8e8893f6bfbe2551862c0c2293"></a><!-- doxytag: member="cmatrix.h::MTX_Skewness" ref="62216f8e8893f6bfbe2551862c0c2293" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Skewness           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample skewness value for the matrix. The skewness is the third central moment divided by the cube of the standard deviation. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="852236cd8aab10732d3611e4a734a509"></a><!-- doxytag: member="cmatrix.h::MTX_SortAscending" ref="852236cd8aab10732d3611e4a734a509" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SortAscending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts each column of M in ascending order. If complex, sorts based on magnitude. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c51a6dc211682abafb3fd39c1fc0e2f"></a><!-- doxytag: member="cmatrix.h::MTX_SortByColumn" ref="7c51a6dc211682abafb3fd39c1fc0e2f" args="(MTX *M, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SortByColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the entire matrix by a specific column. If complex, sorts based on magnitude. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6bcdb5c9dea604a38dc51858a2db367f"></a><!-- doxytag: member="cmatrix.h::MTX_SortColumnAscending" ref="6bcdb5c9dea604a38dc51858a2db367f" args="(MTX *M, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SortColumnAscending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts a specific column in ascending order. If complex, sorts based on magnitude. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69899586008b8c5f0a30770656a1a32c"></a><!-- doxytag: member="cmatrix.h::MTX_SortColumnDescending" ref="69899586008b8c5f0a30770656a1a32c" args="(MTX *M, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SortColumnDescending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts a specific column in descending order. If complex, sorts based on magnitude. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c7cb70acc2ca12b598f581f471b51470"></a><!-- doxytag: member="cmatrix.h::MTX_SortColumnIndexed" ref="c7cb70acc2ca12b598f581f471b51470" args="(MTX *M, const unsigned col, MTX *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SortColumnIndexed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts a specific column in ascending order and fills a <a class="el" href="struct_m_t_x.html" title="The deep level matrix struct. The matrix is either real or complex.">MTX</a> column vector with the sorted index. The index vector will be resized if index-&gt;nrows != M-&gt;nrows If complex, sorts based on magnitude. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="74c05a75393cbf724065ae4d53914f04"></a><!-- doxytag: member="cmatrix.h::MTX_SortDescending" ref="74c05a75393cbf724065ae4d53914f04" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_SortDescending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts each column of M in descending order. If complex, sorts based on magnitude. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c0a73e5670cffc4b824b5abf249f273"></a><!-- doxytag: member="cmatrix.h::MTX_Sqr" ref="8c0a73e5670cffc4b824b5abf249f273" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Sqr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the value^2 of each element in the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="df75a569a1edc476cc879e5531528678"></a><!-- doxytag: member="cmatrix.h::MTX_Sqrt" ref="df75a569a1edc476cc879e5531528678" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Sqrt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sqrt(value) of each element in the matrix. A real matrix is converted to complex if any elements are negative. e.g. sqrt(-1) = -i. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="68f959622826895bc2030d1bff25d64c"></a><!-- doxytag: member="cmatrix.h::MTX_Stdev" ref="68f959622826895bc2030d1bff25d64c" args="(const MTX *M, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Stdev           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample standard deviation for the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a1578331c3ac05b50c41a52623b5527"></a><!-- doxytag: member="cmatrix.h::MTX_Subtract" ref="5a1578331c3ac05b50c41a52623b5527" args="(MTX *A, const MTX *B, const MTX *C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Subtract           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtract A = B-C. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a28dfd23986104c5e0a3f6401d29a72"></a><!-- doxytag: member="cmatrix.h::MTX_Subtract_Inplace" ref="1a28dfd23986104c5e0a3f6401d29a72" args="(MTX *A, const MTX *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Subtract_Inplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtract A -= B, inplace. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9b600cfcf5c18b3eaa24b99b4717604c"></a><!-- doxytag: member="cmatrix.h::MTX_Subtract_Scalar" ref="9b600cfcf5c18b3eaa24b99b4717604c" args="(MTX *M, const double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Subtract_Scalar           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtracts a scalar double from matrix M, ie: M -= 5. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abb93dab812a9ec96ebb0985644c9a21"></a><!-- doxytag: member="cmatrix.h::MTX_Subtract_ScalarComplex" ref="abb93dab812a9ec96ebb0985644c9a21" args="(MTX *M, const double re, const double im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Subtract_ScalarComplex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtracts a scaler complex from matrix M, ie: M -= (5+3i). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="134ad2e521e9e78b4c5ae0cad9a85ec6"></a><!-- doxytag: member="cmatrix.h::MTX_Sum" ref="134ad2e521e9e78b4c5ae0cad9a85ec6" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sum of the data in the matrix . If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d90ffef79154f813218cdc7ff702a9d"></a><!-- doxytag: member="cmatrix.h::MTX_TimeLimit" ref="4d90ffef79154f813218cdc7ff702a9d" args="(MTX *M, const unsigned timeColumn, const double startTime, const double endTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_TimeLimit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>timeColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>endTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alter the matrix, M, so that its data is within [startTime endTime]. This function assumes that time is one of the matrix columns and requires this index, the timeColumn. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. The duration to include </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>M</em>&nbsp;</td><td>
Matrix to be altered </td></tr>
<tr><td valign="top"><em>timeColumn</em>&nbsp;</td><td>
The column containing time </td></tr>
<tr><td valign="top"><em>startTime</em>&nbsp;</td><td>
The specified start time (inclusive) </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="a7047d72cc9145bcf3f2880546efcf10"></a><!-- doxytag: member="cmatrix.h::MTX_TimeMatch" ref="a7047d72cc9145bcf3f2880546efcf10" args="(MTX *A, const unsigned timeColumnA, MTX *B, const unsigned timeColumnB, const unsigned precision, const double rolloverTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_TimeMatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>timeColumnA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>timeColumnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>rolloverTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function matches matrices in time with specified precision where time is a column of each matrix. This function also allows time to rollover at a specified interval. 
<p>
precision 0 = match to whole number <br>
 precision 1 = match to nearest 0.1 <br>
 precision 2 = match to nearest 0.01 <br>
 etc. <br>
 rolloverTime examples <br>
 GPS time of week (s): rolloverTime= 604800.0 <br>
 hours : rolloverTime = 24.0 <br>
 minutes : rolloverTime = 60.0 <br>
<p>
The time data must be non-decreasing but the time may rollover by the specified amount. e.g. rolloverTime = 60.0 <br>
 0,1,2,3,4,...59,60,1,2,5,10,60,1,2,3... <br>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>A</em>&nbsp;</td><td>
The matrix with interpolation times </td></tr>
<tr><td valign="top"><em>timeColumnA</em>&nbsp;</td><td>
The zero based column index for matrix A </td></tr>
<tr><td valign="top"><em>B</em>&nbsp;</td><td>
The matrix to be interpolated </td></tr>
<tr><td valign="top"><em>timeColumnB</em>&nbsp;</td><td>
The zero based column index for matrix B </td></tr>
<tr><td valign="top"><em>precision</em>&nbsp;</td><td>
The rounding precision used for time matching, 0 = whole, 1 = 0.1, 2 = 0.01, etc </td></tr>
<tr><td valign="top"><em>rolloverTime</em>&nbsp;</td><td>
The rollover time, e.g. 60 s for minute based timing, 0.0 means rollovers not allowed </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="aa038f5a95acda862b27e2df3b1b69a7"></a><!-- doxytag: member="cmatrix.h::MTX_TimeWindow" ref="aa038f5a95acda862b27e2df3b1b69a7" args="(MTX *M, const unsigned timeColumn, const double startTime, const double duration, const double rolloverTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_TimeWindow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>timeColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>rolloverTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alter the matrix, M, so that its data is within the startTime to the startTime+duration and compensate for any rollovers in the time system (e.g. GPS time in seconds rolls over at 604800.0 s). This function assumes that time is one of the matrix columns and requires this index, the timeColumn. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. The potential time at which system time rolls over </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>M</em>&nbsp;</td><td>
Matrix to be altered </td></tr>
<tr><td valign="top"><em>timeColumn</em>&nbsp;</td><td>
The column containing time </td></tr>
<tr><td valign="top"><em>startTime</em>&nbsp;</td><td>
The specified start time (inclusive) </td></tr>
<tr><td valign="top"><em>duration</em>&nbsp;</td><td>
The duration to include </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="db5070149dd5e61a7458c9e3149ebbd5"></a><!-- doxytag: member="cmatrix.h::MTX_Trace" ref="db5070149dd5e61a7458c9e3149ebbd5" args="(const MTX *M, double *re, double *im)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Trace           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>im</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the trace of M where M is a square matrix. Trace = Sum of diagonal elements. If the matrix is real, only the real value, re is set, im = 0. If the matrix is complex, both re and im are set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d9cc1c9cc68a104f678e0403e72272dd"></a><!-- doxytag: member="cmatrix.h::MTX_Transpose" ref="d9cc1c9cc68a104f678e0403e72272dd" args="(const MTX *src, MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Transpose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose the matrix src into the matris dst. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="285c3a16c10ca260a59425dbfb951026"></a><!-- doxytag: member="cmatrix.h::MTX_TransposeInplace" ref="285c3a16c10ca260a59425dbfb951026" args="(MTX *M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_TransposeInplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose the matrix as an inplace operation. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="77b7656a696dd32633bb32cc8a607c20"></a><!-- doxytag: member="cmatrix.h::MTX_ValueToString" ref="77b7656a696dd32633bb32cc8a607c20" args="(const double value, const unsigned width, const unsigned precision, const BOOL isReal, const BOOL alignLeft, char *ValueBuffer, const unsigned ValueBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ValueToString           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>isReal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BOOL&nbsp;</td>
          <td class="paramname"> <em>alignLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>ValueBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>ValueBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a value to a string with the specified width and precision. analogous to sprintf( ValueBuffer, "%'blank''-'width.precision'g'", value );. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>value</em>&nbsp;</td><td>
The double value to output. </td></tr>
<tr><td valign="top"><em>width</em>&nbsp;</td><td>
The width of the field. </td></tr>
<tr><td valign="top"><em>precision</em>&nbsp;</td><td>
The precision, g style. </td></tr>
<tr><td valign="top"><em>isReal</em>&nbsp;</td><td>
The the value the real part or the imaginary part. </td></tr>
<tr><td valign="top"><em>alignLeft</em>&nbsp;</td><td>
Align the output left (for real data only). </td></tr>
<tr><td valign="top"><em>ValueBuffer</em>&nbsp;</td><td>
The output buffer. </td></tr>
<tr><td valign="top"><em>ValueBufferSize</em>&nbsp;</td><td>
The size of the output buffer. </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="4f74b95ca4fba8d584e12b2c64ce0004"></a><!-- doxytag: member="cmatrix.h::MTX_Var" ref="4f74b95ca4fba8d584e12b2c64ce0004" args="(const MTX *M, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Var           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the sample variance for the matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="da1e1411e7bfb1f5354ecf4f2babbae2"></a><!-- doxytag: member="cmatrix.h::MTX_Zero" ref="da1e1411e7bfb1f5354ecf4f2babbae2" args="(MTX *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_Zero           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Zero the entire matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fac186d0b357219446e15f815131d5ce"></a><!-- doxytag: member="cmatrix.h::MTX_ZeroColumn" ref="fac186d0b357219446e15f815131d5ce" args="(MTX *dst, const unsigned col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ZeroColumn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Zero all elements in a specified column. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a737cd1fb0f036f4206e0a3d8a01149"></a><!-- doxytag: member="cmatrix.h::MTX_ZeroRow" ref="5a737cd1fb0f036f4206e0a3d8a01149" args="(MTX *dst, const unsigned row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL MTX_ZeroRow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_t_x.html">MTX</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Zero all elements in a specified row. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Nov 29 22:53:31 2007 for The Essential GNSS Project by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
